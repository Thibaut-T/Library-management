/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router-dom";
exports.ids = ["vendor-chunks/react-router-dom"];
exports.modules = {

/***/ "(ssr)/../node_modules/react-router-dom/dist/umd/react-router-dom.development.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/react-router-dom/dist/umd/react-router-dom.development.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/**\n * React Router DOM v6.17.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), __webpack_require__(/*! react-router */ \"(ssr)/../node_modules/react-router/dist/main.js\"), __webpack_require__(/*! @remix-run/router */ \"(ssr)/../node_modules/@remix-run/router/dist/router.cjs.js\")) :\n  0;\n})(this, (function (exports, React, reactRouter, router) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  const defaultMethod = \"get\";\n  const defaultEncType = \"application/x-www-form-urlencoded\";\n  function isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n  }\n  function isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n  }\n  function isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n  }\n  function isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n  }\n  function isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n  }\n  function shouldProcessLinkClick(event, target) {\n    return event.button === 0 && (\n    // Ignore everything but left clicks\n    !target || target === \"_self\") &&\n    // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n    ;\n  }\n\n  /**\n   * Creates a URLSearchParams object using the given initializer.\n   *\n   * This is identical to `new URLSearchParams(init)` except it also\n   * supports arrays as values in the object form of the initializer\n   * instead of just strings. This is convenient when you need multiple\n   * values for a given key, but don't want to use an array initializer.\n   *\n   * For example, instead of:\n   *\n   *   let searchParams = new URLSearchParams([\n   *     ['sort', 'name'],\n   *     ['sort', 'price']\n   *   ]);\n   *\n   * you can do:\n   *\n   *   let searchParams = createSearchParams({\n   *     sort: ['name', 'price']\n   *   });\n   */\n  function createSearchParams(init) {\n    if (init === void 0) {\n      init = \"\";\n    }\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n      let value = init[key];\n      return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n    }, []));\n  }\n  function getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n      // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n      // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n      // web extensions. Relevant Bugzilla tickets:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n      defaultSearchParams.forEach((_, key) => {\n        if (!searchParams.has(key)) {\n          defaultSearchParams.getAll(key).forEach(value => {\n            searchParams.append(key, value);\n          });\n        }\n      });\n    }\n    return searchParams;\n  }\n\n  // Thanks https://github.com/sindresorhus/type-fest!\n\n  // One-time check for submitter support\n  let _formDataSupportsSubmitter = null;\n  function isFormDataSubmitterSupported() {\n    if (_formDataSupportsSubmitter === null) {\n      try {\n        new FormData(document.createElement(\"form\"),\n        // @ts-expect-error if FormData supports the submitter parameter, this will throw\n        0);\n        _formDataSupportsSubmitter = false;\n      } catch (e) {\n        _formDataSupportsSubmitter = true;\n      }\n    }\n    return _formDataSupportsSubmitter;\n  }\n  const supportedFormEncTypes = new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\n  function getFormEncType(encType) {\n    if (encType != null && !supportedFormEncTypes.has(encType)) {\n      router.UNSAFE_warning(false, \"\\\"\" + encType + \"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \" + (\"and will default to \\\"\" + defaultEncType + \"\\\"\")) ;\n      return null;\n    }\n    return encType;\n  }\n  function getFormSubmissionInfo(target, basename) {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    let body;\n    if (isFormElement(target)) {\n      // When grabbing the action from the element, it will have had the basename\n      // prefixed to ensure non-JS scenarios work, so strip it since we'll\n      // re-prefix in the router\n      let attr = target.getAttribute(\"action\");\n      action = attr ? router.stripBasename(attr, basename) : null;\n      method = target.getAttribute(\"method\") || defaultMethod;\n      encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n      formData = new FormData(target);\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n      let form = target.form;\n      if (form == null) {\n        throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n\n      // When grabbing the action from the element, it will have had the basename\n      // prefixed to ensure non-JS scenarios work, so strip it since we'll\n      // re-prefix in the router\n      let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n      action = attr ? router.stripBasename(attr, basename) : null;\n      method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n      encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n\n      // Build a FormData object populated from a form and submitter\n      formData = new FormData(form, target);\n\n      // If this browser doesn't support the `FormData(el, submitter)` format,\n      // then tack on the submitter value at the end.  This is a lightweight\n      // solution that is not 100% spec compliant.  For complete support in older\n      // browsers, consider using the `formdata-submitter-polyfill` package\n      if (!isFormDataSubmitterSupported()) {\n        let {\n          name,\n          type,\n          value\n        } = target;\n        if (type === \"image\") {\n          let prefix = name ? name + \".\" : \"\";\n          formData.append(prefix + \"x\", \"0\");\n          formData.append(prefix + \"y\", \"0\");\n        } else if (name) {\n          formData.append(name, value);\n        }\n      }\n    } else if (isHtmlElement(target)) {\n      throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\n    } else {\n      method = defaultMethod;\n      action = null;\n      encType = defaultEncType;\n      body = target;\n    }\n\n    // Send body for <Form encType=\"text/plain\" so we encode it into text\n    if (formData && encType === \"text/plain\") {\n      body = formData;\n      formData = undefined;\n    }\n    return {\n      action,\n      method: method.toLowerCase(),\n      encType,\n      formData,\n      body\n    };\n  }\n\n  const _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"unstable_viewTransition\"],\n    _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"unstable_viewTransition\", \"children\"],\n    _excluded3 = [\"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"submit\", \"relative\", \"preventScrollReset\", \"unstable_viewTransition\"];\n  //#endregion\n\n  ////////////////////////////////////////////////////////////////////////////////\n  //#region Routers\n  ////////////////////////////////////////////////////////////////////////////////\n  function createBrowserRouter(routes, opts) {\n    return router.createRouter({\n      basename: opts == null ? void 0 : opts.basename,\n      future: _extends({}, opts == null ? void 0 : opts.future, {\n        v7_prependBasename: true\n      }),\n      history: router.createBrowserHistory({\n        window: opts == null ? void 0 : opts.window\n      }),\n      hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n      routes,\n      mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties,\n      window: opts == null ? void 0 : opts.window\n    }).initialize();\n  }\n  function createHashRouter(routes, opts) {\n    return router.createRouter({\n      basename: opts == null ? void 0 : opts.basename,\n      future: _extends({}, opts == null ? void 0 : opts.future, {\n        v7_prependBasename: true\n      }),\n      history: router.createHashHistory({\n        window: opts == null ? void 0 : opts.window\n      }),\n      hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n      routes,\n      mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties,\n      window: opts == null ? void 0 : opts.window\n    }).initialize();\n  }\n  function parseHydrationData() {\n    var _window;\n    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n    if (state && state.errors) {\n      state = _extends({}, state, {\n        errors: deserializeErrors(state.errors)\n      });\n    }\n    return state;\n  }\n  function deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries) {\n      // Hey you!  If you change this, please change the corresponding logic in\n      // serializeErrors in react-router-dom/server.tsx :)\n      if (val && val.__type === \"RouteErrorResponse\") {\n        serialized[key] = new router.UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n      } else if (val && val.__type === \"Error\") {\n        // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n        if (val.__subType) {\n          let ErrorConstructor = window[val.__subType];\n          if (typeof ErrorConstructor === \"function\") {\n            try {\n              // @ts-expect-error\n              let error = new ErrorConstructor(val.message);\n              // Wipe away the client-side stack trace.  Nothing to fill it in with\n              // because we don't serialize SSR stack traces for security reasons\n              error.stack = \"\";\n              serialized[key] = error;\n            } catch (e) {\n              // no-op - fall through and create a normal Error\n            }\n          }\n        }\n        if (serialized[key] == null) {\n          let error = new Error(val.message);\n          // Wipe away the client-side stack trace.  Nothing to fill it in with\n          // because we don't serialize SSR stack traces for security reasons\n          error.stack = \"\";\n          serialized[key] = error;\n        }\n      } else {\n        serialized[key] = val;\n      }\n    }\n    return serialized;\n  }\n\n  //#endregion\n\n  ////////////////////////////////////////////////////////////////////////////////\n  //#region Contexts\n  ////////////////////////////////////////////////////////////////////////////////\n  const ViewTransitionContext = /*#__PURE__*/React__namespace.createContext({\n    isTransitioning: false\n  });\n  {\n    ViewTransitionContext.displayName = \"ViewTransition\";\n  }\n\n  //#endregion\n\n  ////////////////////////////////////////////////////////////////////////////////\n  //#region Components\n  ////////////////////////////////////////////////////////////////////////////////\n\n  /**\n    Webpack + React 17 fails to compile on any of the following because webpack\n    complains that `startTransition` doesn't exist in `React`:\n    * import { startTransition } from \"react\"\n    * import * as React from from \"react\";\n      \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n    * import * as React from from \"react\";\n      \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n    Moving it to a constant such as the following solves the Webpack/React 17 issue:\n    * import * as React from from \"react\";\n      const START_TRANSITION = \"startTransition\";\n      START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n    However, that introduces webpack/terser minification issues in production builds\n    in React 18 where minification/obfuscation ends up removing the call of\n    React.startTransition entirely from the first half of the ternary.  Grabbing\n    this exported reference once up front resolves that issue.\n\n    See https://github.com/remix-run/react-router/issues/10579\n  */\n  const START_TRANSITION = \"startTransition\";\n  const startTransitionImpl = React__namespace[START_TRANSITION];\n  function startTransitionSafe(cb) {\n    if (startTransitionImpl) {\n      startTransitionImpl(cb);\n    } else {\n      cb();\n    }\n  }\n  class Deferred {\n    // @ts-expect-error - no initializer\n\n    // @ts-expect-error - no initializer\n\n    constructor() {\n      this.status = \"pending\";\n      this.promise = new Promise((resolve, reject) => {\n        this.resolve = value => {\n          if (this.status === \"pending\") {\n            this.status = \"resolved\";\n            resolve(value);\n          }\n        };\n        this.reject = reason => {\n          if (this.status === \"pending\") {\n            this.status = \"rejected\";\n            reject(reason);\n          }\n        };\n      });\n    }\n  }\n\n  /**\n   * Given a Remix Router instance, render the appropriate UI\n   */\n  function RouterProvider(_ref) {\n    let {\n      fallbackElement,\n      router,\n      future\n    } = _ref;\n    let [state, setStateImpl] = React__namespace.useState(router.state);\n    let [pendingState, setPendingState] = React__namespace.useState();\n    let [vtContext, setVtContext] = React__namespace.useState({\n      isTransitioning: false\n    });\n    let [renderDfd, setRenderDfd] = React__namespace.useState();\n    let [transition, setTransition] = React__namespace.useState();\n    let [interruption, setInterruption] = React__namespace.useState();\n    let {\n      v7_startTransition\n    } = future || {};\n    let optInStartTransition = React__namespace.useCallback(cb => {\n      if (v7_startTransition) {\n        startTransitionSafe(cb);\n      } else {\n        cb();\n      }\n    }, [v7_startTransition]);\n    let setState = React__namespace.useCallback((newState, _ref2) => {\n      let {\n        unstable_viewTransitionOpts: viewTransitionOpts\n      } = _ref2;\n      if (!viewTransitionOpts || router.window == null || typeof router.window.document.startViewTransition !== \"function\") {\n        // Mid-navigation state update, or startViewTransition isn't available\n        optInStartTransition(() => setStateImpl(newState));\n      } else if (transition && renderDfd) {\n        // Interrupting an in-progress transition, cancel and let everything flush\n        // out, and then kick off a new transition from the interruption state\n        renderDfd.resolve();\n        transition.skipTransition();\n        setInterruption({\n          state: newState,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      } else {\n        // Completed navigation update with opted-in view transitions, let 'er rip\n        setPendingState(newState);\n        setVtContext({\n          isTransitioning: true,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      }\n    }, [optInStartTransition, transition, renderDfd, router.window]);\n\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    React__namespace.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n\n    // When we start a view transition, create a Deferred we can use for the\n    // eventual \"completed\" render\n    React__namespace.useEffect(() => {\n      if (vtContext.isTransitioning) {\n        setRenderDfd(new Deferred());\n      }\n    }, [vtContext.isTransitioning]);\n\n    // Once the deferred is created, kick off startViewTransition() to update the\n    // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n    // happened)\n    React__namespace.useEffect(() => {\n      if (renderDfd && pendingState && router.window) {\n        let newState = pendingState;\n        let renderPromise = renderDfd.promise;\n        let transition = router.window.document.startViewTransition(async () => {\n          optInStartTransition(() => setStateImpl(newState));\n          await renderPromise;\n        });\n        transition.finished.finally(() => {\n          setRenderDfd(undefined);\n          setTransition(undefined);\n          setPendingState(undefined);\n          setVtContext({\n            isTransitioning: false\n          });\n        });\n        setTransition(transition);\n      }\n    }, [optInStartTransition, pendingState, renderDfd, router.window]);\n\n    // When the new location finally renders and is committed to the DOM, this\n    // effect will run to resolve the transition\n    React__namespace.useEffect(() => {\n      if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n        renderDfd.resolve();\n      }\n    }, [renderDfd, transition, state.location, pendingState]);\n\n    // If we get interrupted with a new navigation during a transition, we skip\n    // the active transition, let it cleanup, then kick it off again here\n    React__namespace.useEffect(() => {\n      if (!vtContext.isTransitioning && interruption) {\n        setPendingState(interruption.state);\n        setVtContext({\n          isTransitioning: true,\n          currentLocation: interruption.currentLocation,\n          nextLocation: interruption.nextLocation\n        });\n        setInterruption(undefined);\n      }\n    }, [vtContext.isTransitioning, interruption]);\n    let navigator = React__namespace.useMemo(() => {\n      return {\n        createHref: router.createHref,\n        encodeLocation: router.encodeLocation,\n        go: n => router.navigate(n),\n        push: (to, state, opts) => router.navigate(to, {\n          state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        }),\n        replace: (to, state, opts) => router.navigate(to, {\n          replace: true,\n          state,\n          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n        })\n      };\n    }, [router]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = React__namespace.useMemo(() => ({\n      router,\n      navigator,\n      static: false,\n      basename\n    }), [router, navigator, basename]);\n\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(reactRouter.UNSAFE_DataRouterContext.Provider, {\n      value: dataRouterContext\n    }, /*#__PURE__*/React__namespace.createElement(reactRouter.UNSAFE_DataRouterStateContext.Provider, {\n      value: state\n    }, /*#__PURE__*/React__namespace.createElement(ViewTransitionContext.Provider, {\n      value: vtContext\n    }, /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {\n      basename: basename,\n      location: state.location,\n      navigationType: state.historyAction,\n      navigator: navigator\n    }, state.initialized ? /*#__PURE__*/React__namespace.createElement(DataRoutes, {\n      routes: router.routes,\n      state: state\n    }) : fallbackElement)))), null);\n  }\n  function DataRoutes(_ref3) {\n    let {\n      routes,\n      state\n    } = _ref3;\n    return reactRouter.UNSAFE_useRoutesImpl(routes, undefined, state);\n  }\n  /**\n   * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n   */\n  function BrowserRouter(_ref4) {\n    let {\n      basename,\n      children,\n      future,\n      window\n    } = _ref4;\n    let historyRef = React__namespace.useRef();\n    if (historyRef.current == null) {\n      historyRef.current = router.createBrowserHistory({\n        window,\n        v5Compat: true\n      });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React__namespace.useState({\n      action: history.action,\n      location: history.location\n    });\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);\n    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {\n      basename: basename,\n      children: children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    });\n  }\n  /**\n   * A `<Router>` for use in web browsers. Stores the location in the hash\n   * portion of the URL so it is not sent to the server.\n   */\n  function HashRouter(_ref5) {\n    let {\n      basename,\n      children,\n      future,\n      window\n    } = _ref5;\n    let historyRef = React__namespace.useRef();\n    if (historyRef.current == null) {\n      historyRef.current = router.createHashHistory({\n        window,\n        v5Compat: true\n      });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React__namespace.useState({\n      action: history.action,\n      location: history.location\n    });\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);\n    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {\n      basename: basename,\n      children: children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    });\n  }\n  /**\n   * A `<Router>` that accepts a pre-instantiated history object. It's important\n   * to note that using your own history object is highly discouraged and may add\n   * two versions of the history library to your bundles unless you use the same\n   * version of the history library that React Router uses internally.\n   */\n  function HistoryRouter(_ref6) {\n    let {\n      basename,\n      children,\n      future,\n      history\n    } = _ref6;\n    let [state, setStateImpl] = React__namespace.useState({\n      action: history.action,\n      location: history.location\n    });\n    let {\n      v7_startTransition\n    } = future || {};\n    let setState = React__namespace.useCallback(newState => {\n      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n    }, [setStateImpl, v7_startTransition]);\n    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);\n    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, {\n      basename: basename,\n      children: children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    });\n  }\n  {\n    HistoryRouter.displayName = \"unstable_HistoryRouter\";\n  }\n  const isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\n  const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\n  /**\n   * The public API for rendering a history-aware `<a>`.\n   */\n  const Link = /*#__PURE__*/React__namespace.forwardRef(function LinkWithRef(_ref7, ref) {\n    let {\n        onClick,\n        relative,\n        reloadDocument,\n        replace,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        unstable_viewTransition\n      } = _ref7,\n      rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n    let {\n      basename\n    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);\n\n    // Rendered into <a href> for absolute URLs\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n      // Render the absolute href server- and client-side\n      absoluteHref = to;\n\n      // Only check for external origins client-side\n      if (isBrowser) {\n        try {\n          let currentUrl = new URL(window.location.href);\n          let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n          let path = router.stripBasename(targetUrl.pathname, basename);\n          if (targetUrl.origin === currentUrl.origin && path != null) {\n            // Strip the protocol/origin/basename for same-origin absolute URLs\n            to = path + targetUrl.search + targetUrl.hash;\n          } else {\n            isExternal = true;\n          }\n        } catch (e) {\n          // We can't do external URL detection without a valid URL\n          router.UNSAFE_warning(false, \"<Link to=\\\"\" + to + \"\\\"> contains an invalid URL which will probably break \" + \"when clicked - please update to a valid URL path.\") ;\n        }\n      }\n    }\n\n    // Rendered into <a href> for relative URLs\n    let href = reactRouter.useHref(to, {\n      relative\n    });\n    let internalOnClick = useLinkClickHandler(to, {\n      replace,\n      state,\n      target,\n      preventScrollReset,\n      relative,\n      unstable_viewTransition\n    });\n    function handleClick(event) {\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented) {\n        internalOnClick(event);\n      }\n    }\n    return (\n      /*#__PURE__*/\n      // eslint-disable-next-line jsx-a11y/anchor-has-content\n      React__namespace.createElement(\"a\", _extends({}, rest, {\n        href: absoluteHref || href,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: ref,\n        target: target\n      }))\n    );\n  });\n  {\n    Link.displayName = \"Link\";\n  }\n  /**\n   * A `<Link>` wrapper that knows if it's \"active\" or not.\n   */\n  const NavLink = /*#__PURE__*/React__namespace.forwardRef(function NavLinkWithRef(_ref8, ref) {\n    let {\n        \"aria-current\": ariaCurrentProp = \"page\",\n        caseSensitive = false,\n        className: classNameProp = \"\",\n        end = false,\n        style: styleProp,\n        to,\n        unstable_viewTransition,\n        children\n      } = _ref8,\n      rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n    let path = reactRouter.useResolvedPath(to, {\n      relative: rest.relative\n    });\n    let location = reactRouter.useLocation();\n    let routerState = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);\n    let {\n      navigator\n    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);\n    let isTransitioning = routerState != null &&\n    // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && unstable_viewTransition === true;\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n      locationPathname = locationPathname.toLowerCase();\n      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n      toPathname = toPathname.toLowerCase();\n    }\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n      isActive,\n      isPending,\n      isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n    let className;\n    if (typeof classNameProp === \"function\") {\n      className = classNameProp(renderProps);\n    } else {\n      // If the className prop is not a function, we use a default `active`\n      // class for <NavLink />s that are active. In v5 `active` was the default\n      // value for `activeClassName`, but we are removing that API and can still\n      // use the old default behavior for a cleaner upgrade path and keep the\n      // simple styling rules working as they currently do.\n      className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /*#__PURE__*/React__namespace.createElement(Link, _extends({}, rest, {\n      \"aria-current\": ariaCurrent,\n      className: className,\n      ref: ref,\n      style: style,\n      to: to,\n      unstable_viewTransition: unstable_viewTransition\n    }), typeof children === \"function\" ? children(renderProps) : children);\n  });\n  {\n    NavLink.displayName = \"NavLink\";\n  }\n  /**\n   * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n   * that the interaction with the server is with `fetch` instead of new document\n   * requests, allowing components to add nicer UX to the page as the form is\n   * submitted and returns with data.\n   */\n  const Form = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {\n    let submit = useSubmit();\n    return /*#__PURE__*/React__namespace.createElement(FormImpl, _extends({}, props, {\n      submit: submit,\n      ref: ref\n    }));\n  });\n  {\n    Form.displayName = \"Form\";\n  }\n  const FormImpl = /*#__PURE__*/React__namespace.forwardRef((_ref9, forwardedRef) => {\n    let {\n        reloadDocument,\n        replace,\n        state,\n        method = defaultMethod,\n        action,\n        onSubmit,\n        submit,\n        relative,\n        preventScrollReset,\n        unstable_viewTransition\n      } = _ref9,\n      props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let formAction = useFormAction(action, {\n      relative\n    });\n    let submitHandler = event => {\n      onSubmit && onSubmit(event);\n      if (event.defaultPrevented) return;\n      event.preventDefault();\n      let submitter = event.nativeEvent.submitter;\n      let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n      submit(submitter || event.currentTarget, {\n        method: submitMethod,\n        replace,\n        state,\n        relative,\n        preventScrollReset,\n        unstable_viewTransition\n      });\n    };\n    return /*#__PURE__*/React__namespace.createElement(\"form\", _extends({\n      ref: forwardedRef,\n      method: formMethod,\n      action: formAction,\n      onSubmit: reloadDocument ? onSubmit : submitHandler\n    }, props));\n  });\n  {\n    FormImpl.displayName = \"FormImpl\";\n  }\n  /**\n   * This component will emulate the browser's scroll restoration on location\n   * changes.\n   */\n  function ScrollRestoration(_ref10) {\n    let {\n      getKey,\n      storageKey\n    } = _ref10;\n    useScrollRestoration({\n      getKey,\n      storageKey\n    });\n    return null;\n  }\n  {\n    ScrollRestoration.displayName = \"ScrollRestoration\";\n  }\n  //#endregion\n\n  ////////////////////////////////////////////////////////////////////////////////\n  //#region Hooks\n  ////////////////////////////////////////////////////////////////////////////////\n  var DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\n    DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n    DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n    DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n    return DataRouterHook;\n  }(DataRouterHook || {});\n  var DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\n    DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n    DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    return DataRouterStateHook;\n  }(DataRouterStateHook || {});\n  function getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n  }\n  function useDataRouterContext(hookName) {\n    let ctx = React__namespace.useContext(reactRouter.UNSAFE_DataRouterContext);\n    !ctx ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return ctx;\n  }\n  function useDataRouterState(hookName) {\n    let state = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);\n    !state ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName))  : void 0;\n    return state;\n  }\n\n  /**\n   * Handles the click behavior for router `<Link>` components. This is useful if\n   * you need to create custom `<Link>` components with the same click behavior we\n   * use in our exported `<Link>`.\n   */\n  function useLinkClickHandler(to, _temp) {\n    let {\n      target,\n      replace: replaceProp,\n      state,\n      preventScrollReset,\n      relative,\n      unstable_viewTransition\n    } = _temp === void 0 ? {} : _temp;\n    let navigate = reactRouter.useNavigate();\n    let location = reactRouter.useLocation();\n    let path = reactRouter.useResolvedPath(to, {\n      relative\n    });\n    return React__namespace.useCallback(event => {\n      if (shouldProcessLinkClick(event, target)) {\n        event.preventDefault();\n\n        // If the URL hasn't changed, a regular <a> will do a replace instead of\n        // a push, so do the same here unless the replace prop is explicitly set\n        let replace = replaceProp !== undefined ? replaceProp : reactRouter.createPath(location) === reactRouter.createPath(path);\n        navigate(to, {\n          replace,\n          state,\n          preventScrollReset,\n          relative,\n          unstable_viewTransition\n        });\n      }\n    }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\n  }\n\n  /**\n   * A convenient wrapper for reading and writing search parameters via the\n   * URLSearchParams interface.\n   */\n  function useSearchParams(defaultInit) {\n    router.UNSAFE_warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") ;\n    let defaultSearchParamsRef = React__namespace.useRef(createSearchParams(defaultInit));\n    let hasSetSearchParamsRef = React__namespace.useRef(false);\n    let location = reactRouter.useLocation();\n    let searchParams = React__namespace.useMemo(() =>\n    // Only merge in the defaults if we haven't yet called setSearchParams.\n    // Once we call that we want those to take precedence, otherwise you can't\n    // remove a param with setSearchParams({}) if it has an initial value\n    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);\n    let navigate = reactRouter.useNavigate();\n    let setSearchParams = React__namespace.useCallback((nextInit, navigateOptions) => {\n      const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n      hasSetSearchParamsRef.current = true;\n      navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [navigate, searchParams]);\n    return [searchParams, setSearchParams];\n  }\n\n  /**\n   * Submits a HTML `<form>` to the server without reloading the page.\n   */\n\n  /**\n   * Submits a fetcher `<form>` to the server without reloading the page.\n   */\n\n  function validateClientSideSubmission() {\n    if (typeof document === \"undefined\") {\n      throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n    }\n  }\n\n  /**\n   * Returns a function that may be used to programmatically submit a form (or\n   * some arbitrary data) to the server.\n   */\n  function useSubmit() {\n    let {\n      router\n    } = useDataRouterContext(DataRouterHook.UseSubmit);\n    let {\n      basename\n    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);\n    let currentRouteId = reactRouter.UNSAFE_useRouteId();\n    return React__namespace.useCallback(function (target, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      validateClientSideSubmission();\n      let {\n        action,\n        method,\n        encType,\n        formData,\n        body\n      } = getFormSubmissionInfo(target, basename);\n      router.navigate(options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        replace: options.replace,\n        state: options.state,\n        fromRouteId: currentRouteId,\n        unstable_viewTransition: options.unstable_viewTransition\n      });\n    }, [router, basename, currentRouteId]);\n  }\n\n  /**\n   * Returns the implementation for fetcher.submit\n   */\n  function useSubmitFetcher(fetcherKey, fetcherRouteId) {\n    let {\n      router: router$1\n    } = useDataRouterContext(DataRouterHook.UseSubmitFetcher);\n    let {\n      basename\n    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);\n    return React__namespace.useCallback(function (target, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      validateClientSideSubmission();\n      let {\n        action,\n        method,\n        encType,\n        formData,\n        body\n      } = getFormSubmissionInfo(target, basename);\n      !(fetcherRouteId != null) ? router.UNSAFE_invariant(false, \"No routeId available for useFetcher()\")  : void 0;\n      router$1.fetch(fetcherKey, fetcherRouteId, options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType\n      });\n    }, [router$1, basename, fetcherKey, fetcherRouteId]);\n  }\n\n  // v7: Eventually we should deprecate this entirely in favor of using the\n  // router method directly?\n  function useFormAction(action, _temp2) {\n    let {\n      relative\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      basename\n    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);\n    let routeContext = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);\n    !routeContext ? router.UNSAFE_invariant(false, \"useFormAction must be used inside a RouteContext\")  : void 0;\n    let [match] = routeContext.matches.slice(-1);\n    // Shallow clone path so we can modify it below, otherwise we modify the\n    // object referenced by useMemo inside useResolvedPath\n    let path = _extends({}, reactRouter.useResolvedPath(action ? action : \".\", {\n      relative\n    }));\n\n    // Previously we set the default action to \".\". The problem with this is that\n    // `useResolvedPath(\".\")` excludes search params of the resolved URL. This is\n    // the intended behavior of when \".\" is specifically provided as\n    // the form action, but inconsistent w/ browsers when the action is omitted.\n    // https://github.com/remix-run/remix/issues/927\n    let location = reactRouter.useLocation();\n    if (action == null) {\n      // Safe to write to this directly here since if action was undefined, we\n      // would have called useResolvedPath(\".\") which will never include a search\n      path.search = location.search;\n\n      // When grabbing search params from the URL, remove the automatically\n      // inserted ?index param so we match the useResolvedPath search behavior\n      // which would not include ?index\n      if (match.route.index) {\n        let params = new URLSearchParams(path.search);\n        params.delete(\"index\");\n        path.search = params.toString() ? \"?\" + params.toString() : \"\";\n      }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n      path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the form action.  If this is a root navigation, then just use\n    // the raw basename which allows the basename to have full control over the\n    // presence of a trailing slash on root actions\n    if (basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : router.joinPaths([basename, path.pathname]);\n    }\n    return reactRouter.createPath(path);\n  }\n  function createFetcherForm(fetcherKey, routeId) {\n    let FetcherForm = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {\n      let submit = useSubmitFetcher(fetcherKey, routeId);\n      return /*#__PURE__*/React__namespace.createElement(FormImpl, _extends({}, props, {\n        ref: ref,\n        submit: submit\n      }));\n    });\n    {\n      FetcherForm.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm;\n  }\n  let fetcherId = 0;\n  // TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n  /**\n   * Interacts with route loaders and actions without causing a navigation. Great\n   * for any interaction that stays on the same page.\n   */\n  function useFetcher() {\n    var _route$matches;\n    let {\n      router: router$1\n    } = useDataRouterContext(DataRouterHook.UseFetcher);\n    let route = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);\n    !route ? router.UNSAFE_invariant(false, \"useFetcher must be used inside a RouteContext\")  : void 0;\n    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n    !(routeId != null) ? router.UNSAFE_invariant(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\")  : void 0;\n    let [fetcherKey] = React__namespace.useState(() => String(++fetcherId));\n    let [Form] = React__namespace.useState(() => {\n      !routeId ? router.UNSAFE_invariant(false, \"No routeId available for fetcher.Form()\")  : void 0;\n      return createFetcherForm(fetcherKey, routeId);\n    });\n    let [load] = React__namespace.useState(() => href => {\n      !router$1 ? router.UNSAFE_invariant(false, \"No router available for fetcher.load()\")  : void 0;\n      !routeId ? router.UNSAFE_invariant(false, \"No routeId available for fetcher.load()\")  : void 0;\n      router$1.fetch(fetcherKey, routeId, href);\n    });\n    let submit = useSubmitFetcher(fetcherKey, routeId);\n    let fetcher = router$1.getFetcher(fetcherKey);\n    let fetcherWithComponents = React__namespace.useMemo(() => _extends({\n      Form,\n      submit,\n      load\n    }, fetcher), [fetcher, Form, submit, load]);\n    React__namespace.useEffect(() => {\n      // Is this busted when the React team gets real weird and calls effects\n      // twice on mount?  We really just need to garbage collect here when this\n      // fetcher is no longer around.\n      return () => {\n        if (!router$1) {\n          console.warn(\"No router available to clean up from useFetcher()\");\n          return;\n        }\n        router$1.deleteFetcher(fetcherKey);\n      };\n    }, [router$1, fetcherKey]);\n    return fetcherWithComponents;\n  }\n\n  /**\n   * Provides all fetchers currently on the page. Useful for layouts and parent\n   * routes that need to provide pending/optimistic UI regarding the fetch.\n   */\n  function useFetchers() {\n    let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n    return [...state.fetchers.values()];\n  }\n  const SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\n  let savedScrollPositions = {};\n\n  /**\n   * When rendered inside a RouterProvider, will restore scroll positions on navigations\n   */\n  function useScrollRestoration(_temp3) {\n    let {\n      getKey,\n      storageKey\n    } = _temp3 === void 0 ? {} : _temp3;\n    let {\n      router: router$1\n    } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n    let {\n      restoreScrollPosition,\n      preventScrollReset\n    } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n    let {\n      basename\n    } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);\n    let location = reactRouter.useLocation();\n    let matches = reactRouter.useMatches();\n    let navigation = reactRouter.useNavigation();\n\n    // Trigger manual scroll restoration while we're active\n    React__namespace.useEffect(() => {\n      window.history.scrollRestoration = \"manual\";\n      return () => {\n        window.history.scrollRestoration = \"auto\";\n      };\n    }, []);\n\n    // Save positions on pagehide\n    usePageHide(React__namespace.useCallback(() => {\n      if (navigation.state === \"idle\") {\n        let key = (getKey ? getKey(location, matches) : null) || location.key;\n        savedScrollPositions[key] = window.scrollY;\n      }\n      try {\n        sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n      } catch (error) {\n        router.UNSAFE_warning(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") ;\n      }\n      window.history.scrollRestoration = \"auto\";\n    }, [storageKey, getKey, navigation.state, location, matches]));\n\n    // Read in any saved scroll locations\n    if (typeof document !== \"undefined\") {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React__namespace.useLayoutEffect(() => {\n        try {\n          let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n          if (sessionPositions) {\n            savedScrollPositions = JSON.parse(sessionPositions);\n          }\n        } catch (e) {\n          // no-op, use default empty object\n        }\n      }, [storageKey]);\n\n      // Enable scroll restoration in the router\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React__namespace.useLayoutEffect(() => {\n        let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches) => getKey( // Strip the basename to match useLocation()\n        _extends({}, location, {\n          pathname: router.stripBasename(location.pathname, basename) || location.pathname\n        }), matches) : getKey;\n        let disableScrollRestoration = router$1 == null ? void 0 : router$1.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n        return () => disableScrollRestoration && disableScrollRestoration();\n      }, [router$1, basename, getKey]);\n\n      // Restore scrolling when state.restoreScrollPosition changes\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React__namespace.useLayoutEffect(() => {\n        // Explicit false means don't do anything (used for submissions)\n        if (restoreScrollPosition === false) {\n          return;\n        }\n\n        // been here before, scroll to it\n        if (typeof restoreScrollPosition === \"number\") {\n          window.scrollTo(0, restoreScrollPosition);\n          return;\n        }\n\n        // try to scroll to the hash\n        if (location.hash) {\n          let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n          if (el) {\n            el.scrollIntoView();\n            return;\n          }\n        }\n\n        // Don't reset if this navigation opted out\n        if (preventScrollReset === true) {\n          return;\n        }\n\n        // otherwise go to the top on new locations\n        window.scrollTo(0, 0);\n      }, [location, restoreScrollPosition, preventScrollReset]);\n    }\n  }\n\n  /**\n   * Setup a callback to be fired on the window's `beforeunload` event. This is\n   * useful for saving some data to `window.localStorage` just before the page\n   * refreshes.\n   *\n   * Note: The `callback` argument should be a function created with\n   * `React.useCallback()`.\n   */\n  function useBeforeUnload(callback, options) {\n    let {\n      capture\n    } = options || {};\n    React__namespace.useEffect(() => {\n      let opts = capture != null ? {\n        capture\n      } : undefined;\n      window.addEventListener(\"beforeunload\", callback, opts);\n      return () => {\n        window.removeEventListener(\"beforeunload\", callback, opts);\n      };\n    }, [callback, capture]);\n  }\n\n  /**\n   * Setup a callback to be fired on the window's `pagehide` event. This is\n   * useful for saving some data to `window.localStorage` just before the page\n   * refreshes.  This event is better supported than beforeunload across browsers.\n   *\n   * Note: The `callback` argument should be a function created with\n   * `React.useCallback()`.\n   */\n  function usePageHide(callback, options) {\n    let {\n      capture\n    } = options || {};\n    React__namespace.useEffect(() => {\n      let opts = capture != null ? {\n        capture\n      } : undefined;\n      window.addEventListener(\"pagehide\", callback, opts);\n      return () => {\n        window.removeEventListener(\"pagehide\", callback, opts);\n      };\n    }, [callback, capture]);\n  }\n\n  /**\n   * Wrapper around useBlocker to show a window.confirm prompt to users instead\n   * of building a custom UI with useBlocker.\n   *\n   * Warning: This has *a lot of rough edges* and behaves very differently (and\n   * very incorrectly in some cases) across browsers if user click addition\n   * back/forward navigations while the confirm is open.  Use at your own risk.\n   */\n  function usePrompt(_ref11) {\n    let {\n      when,\n      message\n    } = _ref11;\n    let blocker = reactRouter.unstable_useBlocker(when);\n    React__namespace.useEffect(() => {\n      if (blocker.state === \"blocked\") {\n        let proceed = window.confirm(message);\n        if (proceed) {\n          // This timeout is needed to avoid a weird \"race\" on POP navigations\n          // between the `window.history` revert navigation and the result of\n          // `window.confirm`\n          setTimeout(blocker.proceed, 0);\n        } else {\n          blocker.reset();\n        }\n      }\n    }, [blocker, message]);\n    React__namespace.useEffect(() => {\n      if (blocker.state === \"blocked\" && !when) {\n        blocker.reset();\n      }\n    }, [blocker, when]);\n  }\n\n  /**\n   * Return a boolean indicating if there is an active view transition to the\n   * given href.  You can use this value to render CSS classes or viewTransitionName\n   * styles onto your elements\n   *\n   * @param href The destination href\n   * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n   */\n  function useViewTransitionState(to, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    let vtContext = React__namespace.useContext(ViewTransitionContext);\n    !(vtContext != null) ? router.UNSAFE_invariant(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\")  : void 0;\n    let {\n      basename\n    } = useDataRouterContext(DataRouterHook.useViewTransitionState);\n    let path = reactRouter.useResolvedPath(to, {\n      relative: opts.relative\n    });\n    if (!vtContext.isTransitioning) {\n      return false;\n    }\n    let currentPath = router.stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n    let nextPath = router.stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n\n    // Transition is active if we're going to or coming from the indicated\n    // destination.  This ensures that other PUSH navigations that reverse\n    // an indicated transition apply.  I.e., on the list view you have:\n    //\n    //   <NavLink to=\"/details/1\" unstable_viewTransition>\n    //\n    // If you click the breadcrumb back to the list view:\n    //\n    //   <NavLink to=\"/list\" unstable_viewTransition>\n    //\n    // We should apply the transition because it's indicated as active going\n    // from /list -> /details/1 and therefore should be active on the reverse\n    // (even though this isn't strictly a POP reverse)\n    return router.matchPath(path.pathname, nextPath) != null || router.matchPath(path.pathname, currentPath) != null;\n  }\n\n  //#endregion\n\n  Object.defineProperty(exports, 'AbortedDeferredError', {\n    enumerable: true,\n    get: function () { return reactRouter.AbortedDeferredError; }\n  });\n  Object.defineProperty(exports, 'Await', {\n    enumerable: true,\n    get: function () { return reactRouter.Await; }\n  });\n  Object.defineProperty(exports, 'MemoryRouter', {\n    enumerable: true,\n    get: function () { return reactRouter.MemoryRouter; }\n  });\n  Object.defineProperty(exports, 'Navigate', {\n    enumerable: true,\n    get: function () { return reactRouter.Navigate; }\n  });\n  Object.defineProperty(exports, 'NavigationType', {\n    enumerable: true,\n    get: function () { return reactRouter.NavigationType; }\n  });\n  Object.defineProperty(exports, 'Outlet', {\n    enumerable: true,\n    get: function () { return reactRouter.Outlet; }\n  });\n  Object.defineProperty(exports, 'Route', {\n    enumerable: true,\n    get: function () { return reactRouter.Route; }\n  });\n  Object.defineProperty(exports, 'Router', {\n    enumerable: true,\n    get: function () { return reactRouter.Router; }\n  });\n  Object.defineProperty(exports, 'Routes', {\n    enumerable: true,\n    get: function () { return reactRouter.Routes; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_DataRouterContext', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_DataRouterContext; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_DataRouterStateContext', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_DataRouterStateContext; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_LocationContext', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_LocationContext; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_NavigationContext', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_NavigationContext; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_RouteContext', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_RouteContext; }\n  });\n  Object.defineProperty(exports, 'UNSAFE_useRouteId', {\n    enumerable: true,\n    get: function () { return reactRouter.UNSAFE_useRouteId; }\n  });\n  Object.defineProperty(exports, 'createMemoryRouter', {\n    enumerable: true,\n    get: function () { return reactRouter.createMemoryRouter; }\n  });\n  Object.defineProperty(exports, 'createPath', {\n    enumerable: true,\n    get: function () { return reactRouter.createPath; }\n  });\n  Object.defineProperty(exports, 'createRoutesFromChildren', {\n    enumerable: true,\n    get: function () { return reactRouter.createRoutesFromChildren; }\n  });\n  Object.defineProperty(exports, 'createRoutesFromElements', {\n    enumerable: true,\n    get: function () { return reactRouter.createRoutesFromElements; }\n  });\n  Object.defineProperty(exports, 'defer', {\n    enumerable: true,\n    get: function () { return reactRouter.defer; }\n  });\n  Object.defineProperty(exports, 'generatePath', {\n    enumerable: true,\n    get: function () { return reactRouter.generatePath; }\n  });\n  Object.defineProperty(exports, 'isRouteErrorResponse', {\n    enumerable: true,\n    get: function () { return reactRouter.isRouteErrorResponse; }\n  });\n  Object.defineProperty(exports, 'json', {\n    enumerable: true,\n    get: function () { return reactRouter.json; }\n  });\n  Object.defineProperty(exports, 'matchPath', {\n    enumerable: true,\n    get: function () { return reactRouter.matchPath; }\n  });\n  Object.defineProperty(exports, 'matchRoutes', {\n    enumerable: true,\n    get: function () { return reactRouter.matchRoutes; }\n  });\n  Object.defineProperty(exports, 'parsePath', {\n    enumerable: true,\n    get: function () { return reactRouter.parsePath; }\n  });\n  Object.defineProperty(exports, 'redirect', {\n    enumerable: true,\n    get: function () { return reactRouter.redirect; }\n  });\n  Object.defineProperty(exports, 'redirectDocument', {\n    enumerable: true,\n    get: function () { return reactRouter.redirectDocument; }\n  });\n  Object.defineProperty(exports, 'renderMatches', {\n    enumerable: true,\n    get: function () { return reactRouter.renderMatches; }\n  });\n  Object.defineProperty(exports, 'resolvePath', {\n    enumerable: true,\n    get: function () { return reactRouter.resolvePath; }\n  });\n  Object.defineProperty(exports, 'unstable_useBlocker', {\n    enumerable: true,\n    get: function () { return reactRouter.unstable_useBlocker; }\n  });\n  Object.defineProperty(exports, 'useActionData', {\n    enumerable: true,\n    get: function () { return reactRouter.useActionData; }\n  });\n  Object.defineProperty(exports, 'useAsyncError', {\n    enumerable: true,\n    get: function () { return reactRouter.useAsyncError; }\n  });\n  Object.defineProperty(exports, 'useAsyncValue', {\n    enumerable: true,\n    get: function () { return reactRouter.useAsyncValue; }\n  });\n  Object.defineProperty(exports, 'useHref', {\n    enumerable: true,\n    get: function () { return reactRouter.useHref; }\n  });\n  Object.defineProperty(exports, 'useInRouterContext', {\n    enumerable: true,\n    get: function () { return reactRouter.useInRouterContext; }\n  });\n  Object.defineProperty(exports, 'useLoaderData', {\n    enumerable: true,\n    get: function () { return reactRouter.useLoaderData; }\n  });\n  Object.defineProperty(exports, 'useLocation', {\n    enumerable: true,\n    get: function () { return reactRouter.useLocation; }\n  });\n  Object.defineProperty(exports, 'useMatch', {\n    enumerable: true,\n    get: function () { return reactRouter.useMatch; }\n  });\n  Object.defineProperty(exports, 'useMatches', {\n    enumerable: true,\n    get: function () { return reactRouter.useMatches; }\n  });\n  Object.defineProperty(exports, 'useNavigate', {\n    enumerable: true,\n    get: function () { return reactRouter.useNavigate; }\n  });\n  Object.defineProperty(exports, 'useNavigation', {\n    enumerable: true,\n    get: function () { return reactRouter.useNavigation; }\n  });\n  Object.defineProperty(exports, 'useNavigationType', {\n    enumerable: true,\n    get: function () { return reactRouter.useNavigationType; }\n  });\n  Object.defineProperty(exports, 'useOutlet', {\n    enumerable: true,\n    get: function () { return reactRouter.useOutlet; }\n  });\n  Object.defineProperty(exports, 'useOutletContext', {\n    enumerable: true,\n    get: function () { return reactRouter.useOutletContext; }\n  });\n  Object.defineProperty(exports, 'useParams', {\n    enumerable: true,\n    get: function () { return reactRouter.useParams; }\n  });\n  Object.defineProperty(exports, 'useResolvedPath', {\n    enumerable: true,\n    get: function () { return reactRouter.useResolvedPath; }\n  });\n  Object.defineProperty(exports, 'useRevalidator', {\n    enumerable: true,\n    get: function () { return reactRouter.useRevalidator; }\n  });\n  Object.defineProperty(exports, 'useRouteError', {\n    enumerable: true,\n    get: function () { return reactRouter.useRouteError; }\n  });\n  Object.defineProperty(exports, 'useRouteLoaderData', {\n    enumerable: true,\n    get: function () { return reactRouter.useRouteLoaderData; }\n  });\n  Object.defineProperty(exports, 'useRoutes', {\n    enumerable: true,\n    get: function () { return reactRouter.useRoutes; }\n  });\n  exports.BrowserRouter = BrowserRouter;\n  exports.Form = Form;\n  exports.HashRouter = HashRouter;\n  exports.Link = Link;\n  exports.NavLink = NavLink;\n  exports.RouterProvider = RouterProvider;\n  exports.ScrollRestoration = ScrollRestoration;\n  exports.UNSAFE_ViewTransitionContext = ViewTransitionContext;\n  exports.UNSAFE_useScrollRestoration = useScrollRestoration;\n  exports.createBrowserRouter = createBrowserRouter;\n  exports.createHashRouter = createHashRouter;\n  exports.createSearchParams = createSearchParams;\n  exports.unstable_HistoryRouter = HistoryRouter;\n  exports.unstable_usePrompt = usePrompt;\n  exports.unstable_useViewTransitionState = useViewTransitionState;\n  exports.useBeforeUnload = useBeforeUnload;\n  exports.useFetcher = useFetcher;\n  exports.useFetchers = useFetchers;\n  exports.useFormAction = useFormAction;\n  exports.useLinkClickHandler = useLinkClickHandler;\n  exports.useSearchParams = useSearchParams;\n  exports.useSubmit = useSubmit;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=react-router-dom.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZGlzdC91bWQvcmVhY3Qtcm91dGVyLWRvbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyx5R0FBTyxHQUFHLG1CQUFPLENBQUMscUVBQWMsR0FBRyxtQkFBTyxDQUFDLHFGQUFtQjtBQUN4SixFQUFFLENBQ3FLO0FBQ3ZLLENBQUMsMERBQTBEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcscUJBQXFCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwQkFBMEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdCQUF3QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9kaXN0L3VtZC9yZWFjdC1yb3V0ZXItZG9tLmRldmVsb3BtZW50LmpzP2RkMzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFjdCBSb3V0ZXIgRE9NIHY2LjE3LjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpLCByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKSwgcmVxdWlyZSgnQHJlbWl4LXJ1bi9yb3V0ZXInKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3JlYWN0JywgJ3JlYWN0LXJvdXRlcicsICdAcmVtaXgtcnVuL3JvdXRlciddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLlJlYWN0Um91dGVyRE9NID0ge30sIGdsb2JhbC5SZWFjdCwgZ2xvYmFsLlJlYWN0Um91dGVyLCBnbG9iYWwuUmVtaXhSb3V0ZXIpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cywgUmVhY3QsIHJlYWN0Um91dGVyLCByb3V0ZXIpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZSkge1xuICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG4gIH1cblxuICB2YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG5cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgY29uc3QgZGVmYXVsdE1ldGhvZCA9IFwiZ2V0XCI7XG4gIGNvbnN0IGRlZmF1bHRFbmNUeXBlID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbiAgZnVuY3Rpb24gaXNIdG1sRWxlbWVudChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC50YWdOYW1lID09PSBcInN0cmluZ1wiO1xuICB9XG4gIGZ1bmN0aW9uIGlzQnV0dG9uRWxlbWVudChvYmplY3QpIHtcbiAgICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYnV0dG9uXCI7XG4gIH1cbiAgZnVuY3Rpb24gaXNGb3JtRWxlbWVudChvYmplY3QpIHtcbiAgICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZm9ybVwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdCkge1xuICAgIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICAgIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbiAgfVxuICBmdW5jdGlvbiBzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpIHtcbiAgICByZXR1cm4gZXZlbnQuYnV0dG9uID09PSAwICYmIChcbiAgICAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgICAhdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJlxuICAgIC8vIExldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gSWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICA7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QgdXNpbmcgdGhlIGdpdmVuIGluaXRpYWxpemVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGlkZW50aWNhbCB0byBgbmV3IFVSTFNlYXJjaFBhcmFtcyhpbml0KWAgZXhjZXB0IGl0IGFsc29cbiAgICogc3VwcG9ydHMgYXJyYXlzIGFzIHZhbHVlcyBpbiB0aGUgb2JqZWN0IGZvcm0gb2YgdGhlIGluaXRpYWxpemVyXG4gICAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICAgKiB2YWx1ZXMgZm9yIGEgZ2l2ZW4ga2V5LCBidXQgZG9uJ3Qgd2FudCB0byB1c2UgYW4gYXJyYXkgaW5pdGlhbGl6ZXIuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICAgKlxuICAgKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKFtcbiAgICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gICAqICAgICBbJ3NvcnQnLCAncHJpY2UnXVxuICAgKiAgIF0pO1xuICAgKlxuICAgKiB5b3UgY2FuIGRvOlxuICAgKlxuICAgKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICAgKiAgICAgc29ydDogWyduYW1lJywgJ3ByaWNlJ11cbiAgICogICB9KTtcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtcyhpbml0KSB7XG4gICAgaWYgKGluaXQgPT09IHZvaWQgMCkge1xuICAgICAgaW5pdCA9IFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHR5cGVvZiBpbml0ID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoaW5pdCkgfHwgaW5pdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IGluaXQgOiBPYmplY3Qua2V5cyhpbml0KS5yZWR1Y2UoKG1lbW8sIGtleSkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgICAgcmV0dXJuIG1lbW8uY29uY2F0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHYgPT4gW2tleSwgdl0pIDogW1trZXksIHZhbHVlXV0pO1xuICAgIH0sIFtdKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24obG9jYXRpb25TZWFyY2gsIGRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKGxvY2F0aW9uU2VhcmNoKTtcbiAgICBpZiAoZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICAgICAgLy8gVXNlIGBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goLi4uKWAgaGVyZSBpbnN0ZWFkIG9mIGl0ZXJhdGluZyBvZlxuICAgICAgLy8gYGRlZmF1bHRTZWFyY2hQYXJhbXMua2V5cygpYCB0byB3b3JrLWFyb3VuZCBhIGJ1ZyBpbiBGaXJlZm94IHJlbGF0ZWQgdG9cbiAgICAgIC8vIHdlYiBleHRlbnNpb25zLiBSZWxldmFudCBCdWd6aWxsYSB0aWNrZXRzOlxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQxNDYwMlxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTAyMzk4NFxuICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmdldEFsbChrZXkpLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZWFyY2hQYXJhbXM7XG4gIH1cblxuICAvLyBUaGFua3MgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy90eXBlLWZlc3QhXG5cbiAgLy8gT25lLXRpbWUgY2hlY2sgZm9yIHN1Ym1pdHRlciBzdXBwb3J0XG4gIGxldCBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IG51bGw7XG4gIGZ1bmN0aW9uIGlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID09PSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRm9ybURhdGEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaWYgRm9ybURhdGEgc3VwcG9ydHMgdGhlIHN1Ym1pdHRlciBwYXJhbWV0ZXIsIHRoaXMgd2lsbCB0aHJvd1xuICAgICAgICAwKTtcbiAgICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXI7XG4gIH1cbiAgY29uc3Qgc3VwcG9ydGVkRm9ybUVuY1R5cGVzID0gbmV3IFNldChbXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsIFwidGV4dC9wbGFpblwiXSk7XG4gIGZ1bmN0aW9uIGdldEZvcm1FbmNUeXBlKGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jVHlwZSAhPSBudWxsICYmICFzdXBwb3J0ZWRGb3JtRW5jVHlwZXMuaGFzKGVuY1R5cGUpKSB7XG4gICAgICByb3V0ZXIuVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiXFxcIlwiICsgZW5jVHlwZSArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBgZW5jVHlwZWAgZm9yIGA8Rm9ybT5gL2A8ZmV0Y2hlci5Gb3JtPmAgXCIgKyAoXCJhbmQgd2lsbCBkZWZhdWx0IHRvIFxcXCJcIiArIGRlZmF1bHRFbmNUeXBlICsgXCJcXFwiXCIpKSA7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGVuY1R5cGU7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKHRhcmdldCwgYmFzZW5hbWUpIHtcbiAgICBsZXQgbWV0aG9kO1xuICAgIGxldCBhY3Rpb247XG4gICAgbGV0IGVuY1R5cGU7XG4gICAgbGV0IGZvcm1EYXRhO1xuICAgIGxldCBib2R5O1xuICAgIGlmIChpc0Zvcm1FbGVtZW50KHRhcmdldCkpIHtcbiAgICAgIC8vIFdoZW4gZ3JhYmJpbmcgdGhlIGFjdGlvbiBmcm9tIHRoZSBlbGVtZW50LCBpdCB3aWxsIGhhdmUgaGFkIHRoZSBiYXNlbmFtZVxuICAgICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAgIC8vIHJlLXByZWZpeCBpbiB0aGUgcm91dGVyXG4gICAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgICBhY3Rpb24gPSBhdHRyID8gcm91dGVyLnN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcbiAgICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICAgIGVuY1R5cGUgPSBnZXRGb3JtRW5jVHlwZSh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSkgfHwgZGVmYXVsdEVuY1R5cGU7XG4gICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSh0YXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHwgaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJiAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICAgIGxldCBmb3JtID0gdGFyZ2V0LmZvcm07XG4gICAgICBpZiAoZm9ybSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiBvciA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIj4gd2l0aG91dCBhIDxmb3JtPlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gPGJ1dHRvbj4vPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gbWF5IG92ZXJyaWRlIGF0dHJpYnV0ZXMgb2YgPGZvcm0+XG5cbiAgICAgIC8vIFdoZW4gZ3JhYmJpbmcgdGhlIGFjdGlvbiBmcm9tIHRoZSBlbGVtZW50LCBpdCB3aWxsIGhhdmUgaGFkIHRoZSBiYXNlbmFtZVxuICAgICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAgIC8vIHJlLXByZWZpeCBpbiB0aGUgcm91dGVyXG4gICAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtYWN0aW9uXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgICAgYWN0aW9uID0gYXR0ciA/IHJvdXRlci5zdHJpcEJhc2VuYW1lKGF0dHIsIGJhc2VuYW1lKSA6IG51bGw7XG4gICAgICBtZXRob2QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSkgfHwgZ2V0Rm9ybUVuY1R5cGUoZm9ybS5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcblxuICAgICAgLy8gQnVpbGQgYSBGb3JtRGF0YSBvYmplY3QgcG9wdWxhdGVkIGZyb20gYSBmb3JtIGFuZCBzdWJtaXR0ZXJcbiAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0sIHRhcmdldCk7XG5cbiAgICAgIC8vIElmIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIGBGb3JtRGF0YShlbCwgc3VibWl0dGVyKWAgZm9ybWF0LFxuICAgICAgLy8gdGhlbiB0YWNrIG9uIHRoZSBzdWJtaXR0ZXIgdmFsdWUgYXQgdGhlIGVuZC4gIFRoaXMgaXMgYSBsaWdodHdlaWdodFxuICAgICAgLy8gc29sdXRpb24gdGhhdCBpcyBub3QgMTAwJSBzcGVjIGNvbXBsaWFudC4gIEZvciBjb21wbGV0ZSBzdXBwb3J0IGluIG9sZGVyXG4gICAgICAvLyBicm93c2VycywgY29uc2lkZXIgdXNpbmcgdGhlIGBmb3JtZGF0YS1zdWJtaXR0ZXItcG9seWZpbGxgIHBhY2thZ2VcbiAgICAgIGlmICghaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0gPSB0YXJnZXQ7XG4gICAgICAgIGlmICh0eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgICBsZXQgcHJlZml4ID0gbmFtZSA/IG5hbWUgKyBcIi5cIiA6IFwiXCI7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKHByZWZpeCArIFwieFwiLCBcIjBcIik7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKHByZWZpeCArIFwieVwiLCBcIjBcIik7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN1Ym1pdCBlbGVtZW50IHRoYXQgaXMgbm90IDxmb3JtPiwgPGJ1dHRvbj4sIG9yIFwiICsgXCI8aW5wdXQgdHlwZT1cXFwic3VibWl0fGltYWdlXFxcIj5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1ldGhvZCA9IGRlZmF1bHRNZXRob2Q7XG4gICAgICBhY3Rpb24gPSBudWxsO1xuICAgICAgZW5jVHlwZSA9IGRlZmF1bHRFbmNUeXBlO1xuICAgICAgYm9keSA9IHRhcmdldDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIGJvZHkgZm9yIDxGb3JtIGVuY1R5cGU9XCJ0ZXh0L3BsYWluXCIgc28gd2UgZW5jb2RlIGl0IGludG8gdGV4dFxuICAgIGlmIChmb3JtRGF0YSAmJiBlbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgYm9keSA9IGZvcm1EYXRhO1xuICAgICAgZm9ybURhdGEgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb24sXG4gICAgICBtZXRob2Q6IG1ldGhvZC50b0xvd2VyQ2FzZSgpLFxuICAgICAgZW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAgYm9keVxuICAgIH07XG4gIH1cblxuICBjb25zdCBfZXhjbHVkZWQgPSBbXCJvbkNsaWNrXCIsIFwicmVsYXRpdmVcIiwgXCJyZWxvYWREb2N1bWVudFwiLCBcInJlcGxhY2VcIiwgXCJzdGF0ZVwiLCBcInRhcmdldFwiLCBcInRvXCIsIFwicHJldmVudFNjcm9sbFJlc2V0XCIsIFwidW5zdGFibGVfdmlld1RyYW5zaXRpb25cIl0sXG4gICAgX2V4Y2x1ZGVkMiA9IFtcImFyaWEtY3VycmVudFwiLCBcImNhc2VTZW5zaXRpdmVcIiwgXCJjbGFzc05hbWVcIiwgXCJlbmRcIiwgXCJzdHlsZVwiLCBcInRvXCIsIFwidW5zdGFibGVfdmlld1RyYW5zaXRpb25cIiwgXCJjaGlsZHJlblwiXSxcbiAgICBfZXhjbHVkZWQzID0gW1wicmVsb2FkRG9jdW1lbnRcIiwgXCJyZXBsYWNlXCIsIFwic3RhdGVcIiwgXCJtZXRob2RcIiwgXCJhY3Rpb25cIiwgXCJvblN1Ym1pdFwiLCBcInN1Ym1pdFwiLCBcInJlbGF0aXZlXCIsIFwicHJldmVudFNjcm9sbFJlc2V0XCIsIFwidW5zdGFibGVfdmlld1RyYW5zaXRpb25cIl07XG4gIC8vI2VuZHJlZ2lvblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vI3JlZ2lvbiBSb3V0ZXJzXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gICAgcmV0dXJuIHJvdXRlci5jcmVhdGVSb3V0ZXIoe1xuICAgICAgYmFzZW5hbWU6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYmFzZW5hbWUsXG4gICAgICBmdXR1cmU6IF9leHRlbmRzKHt9LCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmZ1dHVyZSwge1xuICAgICAgICB2N19wcmVwZW5kQmFzZW5hbWU6IHRydWVcbiAgICAgIH0pLFxuICAgICAgaGlzdG9yeTogcm91dGVyLmNyZWF0ZUJyb3dzZXJIaXN0b3J5KHtcbiAgICAgICAgd2luZG93OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLndpbmRvd1xuICAgICAgfSksXG4gICAgICBoeWRyYXRpb25EYXRhOiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5oeWRyYXRpb25EYXRhKSB8fCBwYXJzZUh5ZHJhdGlvbkRhdGEoKSxcbiAgICAgIHJvdXRlcyxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczogcmVhY3RSb3V0ZXIuVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyxcbiAgICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcbiAgICB9KS5pbml0aWFsaXplKCk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaFJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgICByZXR1cm4gcm91dGVyLmNyZWF0ZVJvdXRlcih7XG4gICAgICBiYXNlbmFtZTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iYXNlbmFtZSxcbiAgICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxuICAgICAgfSksXG4gICAgICBoaXN0b3J5OiByb3V0ZXIuY3JlYXRlSGFzaEhpc3Rvcnkoe1xuICAgICAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gICAgICB9KSxcbiAgICAgIGh5ZHJhdGlvbkRhdGE6IChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmh5ZHJhdGlvbkRhdGEpIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgICAgcm91dGVzLFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzOiByZWFjdFJvdXRlci5VTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgICAgd2luZG93OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLndpbmRvd1xuICAgIH0pLmluaXRpYWxpemUoKTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUh5ZHJhdGlvbkRhdGEoKSB7XG4gICAgdmFyIF93aW5kb3c7XG4gICAgbGV0IHN0YXRlID0gKF93aW5kb3cgPSB3aW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YTtcbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgICBzdGF0ZSA9IF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBlcnJvcnM6IGRlc2VyaWFsaXplRXJyb3JzKHN0YXRlLmVycm9ycylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gZGVzZXJpYWxpemVFcnJvcnMoZXJyb3JzKSB7XG4gICAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICAgIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzKTtcbiAgICBsZXQgc2VyaWFsaXplZCA9IHt9O1xuICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgICAgLy8gSGV5IHlvdSEgIElmIHlvdSBjaGFuZ2UgdGhpcywgcGxlYXNlIGNoYW5nZSB0aGUgY29ycmVzcG9uZGluZyBsb2dpYyBpblxuICAgICAgLy8gc2VyaWFsaXplRXJyb3JzIGluIHJlYWN0LXJvdXRlci1kb20vc2VydmVyLnRzeCA6KVxuICAgICAgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIlJvdXRlRXJyb3JSZXNwb25zZVwiKSB7XG4gICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IG5ldyByb3V0ZXIuVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsKHZhbC5zdGF0dXMsIHZhbC5zdGF0dXNUZXh0LCB2YWwuZGF0YSwgdmFsLmludGVybmFsID09PSB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIHJlY29uc3RydWN0IHRoZSByaWdodCB0eXBlIG9mIEVycm9yIChpLmUuLCBSZWZlcmVuY2VFcnJvcilcbiAgICAgICAgaWYgKHZhbC5fX3N1YlR5cGUpIHtcbiAgICAgICAgICBsZXQgRXJyb3JDb25zdHJ1Y3RvciA9IHdpbmRvd1t2YWwuX19zdWJUeXBlXTtcbiAgICAgICAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWwubWVzc2FnZSk7XG4gICAgICAgICAgICAgIC8vIFdpcGUgYXdheSB0aGUgY2xpZW50LXNpZGUgc3RhY2sgdHJhY2UuICBOb3RoaW5nIHRvIGZpbGwgaXQgaW4gd2l0aFxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHNlcmlhbGl6ZSBTU1Igc3RhY2sgdHJhY2VzIGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gXCJcIjtcbiAgICAgICAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIG5vLW9wIC0gZmFsbCB0aHJvdWdoIGFuZCBjcmVhdGUgYSBub3JtYWwgRXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcmlhbGl6ZWRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgICAvLyBXaXBlIGF3YXkgdGhlIGNsaWVudC1zaWRlIHN0YWNrIHRyYWNlLiAgTm90aGluZyB0byBmaWxsIGl0IGluIHdpdGhcbiAgICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHNlcmlhbGl6ZSBTU1Igc3RhY2sgdHJhY2VzIGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgZXJyb3Iuc3RhY2sgPSBcIlwiO1xuICAgICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG5cbiAgLy8jZW5kcmVnaW9uXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8jcmVnaW9uIENvbnRleHRzXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGNvbnN0IFZpZXdUcmFuc2l0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUNvbnRleHQoe1xuICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgfSk7XG4gIHtcbiAgICBWaWV3VHJhbnNpdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlZpZXdUcmFuc2l0aW9uXCI7XG4gIH1cblxuICAvLyNlbmRyZWdpb25cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyNyZWdpb24gQ29tcG9uZW50c1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgIFdlYnBhY2sgKyBSZWFjdCAxNyBmYWlscyB0byBjb21waWxlIG9uIGFueSBvZiB0aGUgZm9sbG93aW5nIGJlY2F1c2Ugd2VicGFja1xuICAgIGNvbXBsYWlucyB0aGF0IGBzdGFydFRyYW5zaXRpb25gIGRvZXNuJ3QgZXhpc3QgaW4gYFJlYWN0YDpcbiAgICAqIGltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gXCJyZWFjdFwiXG4gICAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcbiAgICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3RbXCJzdGFydFRyYW5zaXRpb25cIl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgICBNb3ZpbmcgaXQgdG8gYSBjb25zdGFudCBzdWNoIGFzIHRoZSBmb2xsb3dpbmcgc29sdmVzIHRoZSBXZWJwYWNrL1JlYWN0IDE3IGlzc3VlOlxuICAgICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICAgIGNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuICAgICAgU1RBUlRfVFJBTlNJVElPTiBpbiBSZWFjdCA/IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gICAgSG93ZXZlciwgdGhhdCBpbnRyb2R1Y2VzIHdlYnBhY2svdGVyc2VyIG1pbmlmaWNhdGlvbiBpc3N1ZXMgaW4gcHJvZHVjdGlvbiBidWlsZHNcbiAgICBpbiBSZWFjdCAxOCB3aGVyZSBtaW5pZmljYXRpb24vb2JmdXNjYXRpb24gZW5kcyB1cCByZW1vdmluZyB0aGUgY2FsbCBvZlxuICAgIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbiBlbnRpcmVseSBmcm9tIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSB0ZXJuYXJ5LiAgR3JhYmJpbmdcbiAgICB0aGlzIGV4cG9ydGVkIHJlZmVyZW5jZSBvbmNlIHVwIGZyb250IHJlc29sdmVzIHRoYXQgaXNzdWUuXG5cbiAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzEwNTc5XG4gICovXG4gIGNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuICBjb25zdCBzdGFydFRyYW5zaXRpb25JbXBsID0gUmVhY3RfX25hbWVzcGFjZVtTVEFSVF9UUkFOU0lUSU9OXTtcbiAgZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uU2FmZShjYikge1xuICAgIGlmIChzdGFydFRyYW5zaXRpb25JbXBsKSB7XG4gICAgICBzdGFydFRyYW5zaXRpb25JbXBsKGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRGVmZXJyZWQge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBubyBpbml0aWFsaXplclxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIG5vIGluaXRpYWxpemVyXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMucmVzb2x2ZSA9IHZhbHVlID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVzb2x2ZWRcIjtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWplY3QgPSByZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVtaXggUm91dGVyIGluc3RhbmNlLCByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIFVJXG4gICAqL1xuICBmdW5jdGlvbiBSb3V0ZXJQcm92aWRlcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGZhbGxiYWNrRWxlbWVudCxcbiAgICAgIHJvdXRlcixcbiAgICAgIGZ1dHVyZVxuICAgIH0gPSBfcmVmO1xuICAgIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKHJvdXRlci5zdGF0ZSk7XG4gICAgbGV0IFtwZW5kaW5nU3RhdGUsIHNldFBlbmRpbmdTdGF0ZV0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKCk7XG4gICAgbGV0IFt2dENvbnRleHQsIHNldFZ0Q29udGV4dF0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKHtcbiAgICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgICB9KTtcbiAgICBsZXQgW3JlbmRlckRmZCwgc2V0UmVuZGVyRGZkXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoKTtcbiAgICBsZXQgW3RyYW5zaXRpb24sIHNldFRyYW5zaXRpb25dID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSgpO1xuICAgIGxldCBbaW50ZXJydXB0aW9uLCBzZXRJbnRlcnJ1cHRpb25dID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSgpO1xuICAgIGxldCB7XG4gICAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgICB9ID0gZnV0dXJlIHx8IHt9O1xuICAgIGxldCBvcHRJblN0YXJ0VHJhbnNpdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soY2IgPT4ge1xuICAgICAgaWYgKHY3X3N0YXJ0VHJhbnNpdGlvbikge1xuICAgICAgICBzdGFydFRyYW5zaXRpb25TYWZlKGNiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfSwgW3Y3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICAgIGxldCBzZXRTdGF0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soKG5ld1N0YXRlLCBfcmVmMikgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25PcHRzOiB2aWV3VHJhbnNpdGlvbk9wdHNcbiAgICAgIH0gPSBfcmVmMjtcbiAgICAgIGlmICghdmlld1RyYW5zaXRpb25PcHRzIHx8IHJvdXRlci53aW5kb3cgPT0gbnVsbCB8fCB0eXBlb2Ygcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gTWlkLW5hdmlnYXRpb24gc3RhdGUgdXBkYXRlLCBvciBzdGFydFZpZXdUcmFuc2l0aW9uIGlzbid0IGF2YWlsYWJsZVxuICAgICAgICBvcHRJblN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbiAmJiByZW5kZXJEZmQpIHtcbiAgICAgICAgLy8gSW50ZXJydXB0aW5nIGFuIGluLXByb2dyZXNzIHRyYW5zaXRpb24sIGNhbmNlbCBhbmQgbGV0IGV2ZXJ5dGhpbmcgZmx1c2hcbiAgICAgICAgLy8gb3V0LCBhbmQgdGhlbiBraWNrIG9mZiBhIG5ldyB0cmFuc2l0aW9uIGZyb20gdGhlIGludGVycnVwdGlvbiBzdGF0ZVxuICAgICAgICByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICAgIHNldEludGVycnVwdGlvbih7XG4gICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb21wbGV0ZWQgbmF2aWdhdGlvbiB1cGRhdGUgd2l0aCBvcHRlZC1pbiB2aWV3IHRyYW5zaXRpb25zLCBsZXQgJ2VyIHJpcFxuICAgICAgICBzZXRQZW5kaW5nU3RhdGUobmV3U3RhdGUpO1xuICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtvcHRJblN0YXJ0VHJhbnNpdGlvbiwgdHJhbnNpdGlvbiwgcmVuZGVyRGZkLCByb3V0ZXIud2luZG93XSk7XG5cbiAgICAvLyBOZWVkIHRvIHVzZSBhIGxheW91dCBlZmZlY3QgaGVyZSBzbyB3ZSBhcmUgc3Vic2NyaWJlZCBlYXJseSBlbm91Z2ggdG9cbiAgICAvLyBwaWNrIHVwIG9uIGFueSByZW5kZXItZHJpdmVuIHJlZGlyZWN0cy9uYXZpZ2F0aW9ucyAodXNlRWZmZWN0LzxOYXZpZ2F0ZT4pXG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyLnN1YnNjcmliZShzZXRTdGF0ZSksIFtyb3V0ZXIsIHNldFN0YXRlXSk7XG5cbiAgICAvLyBXaGVuIHdlIHN0YXJ0IGEgdmlldyB0cmFuc2l0aW9uLCBjcmVhdGUgYSBEZWZlcnJlZCB3ZSBjYW4gdXNlIGZvciB0aGVcbiAgICAvLyBldmVudHVhbCBcImNvbXBsZXRlZFwiIHJlbmRlclxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmICh2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHNldFJlbmRlckRmZChuZXcgRGVmZXJyZWQoKSk7XG4gICAgICB9XG4gICAgfSwgW3Z0Q29udGV4dC5pc1RyYW5zaXRpb25pbmddKTtcblxuICAgIC8vIE9uY2UgdGhlIGRlZmVycmVkIGlzIGNyZWF0ZWQsIGtpY2sgb2ZmIHN0YXJ0Vmlld1RyYW5zaXRpb24oKSB0byB1cGRhdGUgdGhlXG4gICAgLy8gRE9NIGFuZCB0aGVuIHdhaXQgb24gdGhlIERlZmVycmVkIHRvIHJlc29sdmUgKGluZGljYXRpbmcgdGhlIERPTSB1cGRhdGUgaGFzXG4gICAgLy8gaGFwcGVuZWQpXG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKHJlbmRlckRmZCAmJiBwZW5kaW5nU3RhdGUgJiYgcm91dGVyLndpbmRvdykge1xuICAgICAgICBsZXQgbmV3U3RhdGUgPSBwZW5kaW5nU3RhdGU7XG4gICAgICAgIGxldCByZW5kZXJQcm9taXNlID0gcmVuZGVyRGZkLnByb21pc2U7XG4gICAgICAgIGxldCB0cmFuc2l0aW9uID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBvcHRJblN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgICBhd2FpdCByZW5kZXJQcm9taXNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNpdGlvbi5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICBzZXRSZW5kZXJEZmQodW5kZWZpbmVkKTtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uKHVuZGVmaW5lZCk7XG4gICAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgICB9XG4gICAgfSwgW29wdEluU3RhcnRUcmFuc2l0aW9uLCBwZW5kaW5nU3RhdGUsIHJlbmRlckRmZCwgcm91dGVyLndpbmRvd10pO1xuXG4gICAgLy8gV2hlbiB0aGUgbmV3IGxvY2F0aW9uIGZpbmFsbHkgcmVuZGVycyBhbmQgaXMgY29tbWl0dGVkIHRvIHRoZSBET00sIHRoaXNcbiAgICAvLyBlZmZlY3Qgd2lsbCBydW4gdG8gcmVzb2x2ZSB0aGUgdHJhbnNpdGlvblxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHN0YXRlLmxvY2F0aW9uLmtleSA9PT0gcGVuZGluZ1N0YXRlLmxvY2F0aW9uLmtleSkge1xuICAgICAgICByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0sIFtyZW5kZXJEZmQsIHRyYW5zaXRpb24sIHN0YXRlLmxvY2F0aW9uLCBwZW5kaW5nU3RhdGVdKTtcblxuICAgIC8vIElmIHdlIGdldCBpbnRlcnJ1cHRlZCB3aXRoIGEgbmV3IG5hdmlnYXRpb24gZHVyaW5nIGEgdHJhbnNpdGlvbiwgd2Ugc2tpcFxuICAgIC8vIHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgbGV0IGl0IGNsZWFudXAsIHRoZW4ga2ljayBpdCBvZmYgYWdhaW4gaGVyZVxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiBpbnRlcnJ1cHRpb24pIHtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlKGludGVycnVwdGlvbi5zdGF0ZSk7XG4gICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogaW50ZXJydXB0aW9uLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGludGVycnVwdGlvbi5uZXh0TG9jYXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHNldEludGVycnVwdGlvbih1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH0sIFt2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nLCBpbnRlcnJ1cHRpb25dKTtcbiAgICBsZXQgbmF2aWdhdG9yID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKCgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgICBlbmNvZGVMb2NhdGlvbjogcm91dGVyLmVuY29kZUxvY2F0aW9uLFxuICAgICAgICBnbzogbiA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICAgIHB1c2g6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgICAgfSksXG4gICAgICAgIHJlcGxhY2U6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9LCBbcm91dGVyXSk7XG4gICAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuICAgIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiAoe1xuICAgICAgcm91dGVyLFxuICAgICAgbmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgIGJhc2VuYW1lXG4gICAgfSksIFtyb3V0ZXIsIG5hdmlnYXRvciwgYmFzZW5hbWVdKTtcblxuICAgIC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcbiAgICAvLyB1c2VJZCBoYXBweSB3aGVuIHdlIGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHNpbmNlIHdlIG1heSBoYXZlIGEgPHNjcmlwdD4gaGVyZVxuICAgIC8vIGNvbnRhaW5pbmcgdGhlIGh5ZHJhdGVkIHNlcnZlci1zaWRlIHN0YXRpY0NvbnRleHQgKGZyb20gU3RhdGljUm91dGVyUHJvdmlkZXIpLlxuICAgIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xuICAgIC8vIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGl0IHJlbWFpbnMgdGhlIHNhbWUgb24gdGhlIGNsaWVudCBldmVuIHRob3VnaFxuICAgIC8vIHdlIGRvbid0IG5lZWQgdGhlIDxzY3JpcHQ+IHRhZ1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQocmVhY3RSb3V0ZXIuVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHRcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJlYWN0Um91dGVyLlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogc3RhdGVcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFZpZXdUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHZ0Q29udGV4dFxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQocmVhY3RSb3V0ZXIuUm91dGVyLCB7XG4gICAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yXG4gICAgfSwgc3RhdGUuaW5pdGlhbGl6ZWQgPyAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXMsIHtcbiAgICAgIHJvdXRlczogcm91dGVyLnJvdXRlcyxcbiAgICAgIHN0YXRlOiBzdGF0ZVxuICAgIH0pIDogZmFsbGJhY2tFbGVtZW50KSkpKSwgbnVsbCk7XG4gIH1cbiAgZnVuY3Rpb24gRGF0YVJvdXRlcyhfcmVmMykge1xuICAgIGxldCB7XG4gICAgICByb3V0ZXMsXG4gICAgICBzdGF0ZVxuICAgIH0gPSBfcmVmMztcbiAgICByZXR1cm4gcmVhY3RSb3V0ZXIuVU5TQUZFX3VzZVJvdXRlc0ltcGwocm91dGVzLCB1bmRlZmluZWQsIHN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBQcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAgICovXG4gIGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoX3JlZjQpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZ1dHVyZSxcbiAgICAgIHdpbmRvd1xuICAgIH0gPSBfcmVmNDtcbiAgICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSByb3V0ZXIuY3JlYXRlQnJvd3Nlckhpc3Rvcnkoe1xuICAgICAgICB3aW5kb3csXG4gICAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gICAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoe1xuICAgICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gICAgfSk7XG4gICAgbGV0IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICAgIH0gPSBmdXR1cmUgfHwge307XG4gICAgbGV0IHNldFN0YXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICAgIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQocmVhY3RSb3V0ZXIuUm91dGVyLCB7XG4gICAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gU3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB0aGUgaGFzaFxuICAgKiBwb3J0aW9uIG9mIHRoZSBVUkwgc28gaXQgaXMgbm90IHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICovXG4gIGZ1bmN0aW9uIEhhc2hSb3V0ZXIoX3JlZjUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZ1dHVyZSxcbiAgICAgIHdpbmRvd1xuICAgIH0gPSBfcmVmNTtcbiAgICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSByb3V0ZXIuY3JlYXRlSGFzaEhpc3Rvcnkoe1xuICAgICAgICB3aW5kb3csXG4gICAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gICAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoe1xuICAgICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gICAgfSk7XG4gICAgbGV0IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICAgIH0gPSBmdXR1cmUgfHwge307XG4gICAgbGV0IHNldFN0YXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICAgIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQocmVhY3RSb3V0ZXIuUm91dGVyLCB7XG4gICAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgYDxSb3V0ZXI+YCB0aGF0IGFjY2VwdHMgYSBwcmUtaW5zdGFudGlhdGVkIGhpc3Rvcnkgb2JqZWN0LiBJdCdzIGltcG9ydGFudFxuICAgKiB0byBub3RlIHRoYXQgdXNpbmcgeW91ciBvd24gaGlzdG9yeSBvYmplY3QgaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGFuZCBtYXkgYWRkXG4gICAqIHR3byB2ZXJzaW9ucyBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRvIHlvdXIgYnVuZGxlcyB1bmxlc3MgeW91IHVzZSB0aGUgc2FtZVxuICAgKiB2ZXJzaW9uIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdGhhdCBSZWFjdCBSb3V0ZXIgdXNlcyBpbnRlcm5hbGx5LlxuICAgKi9cbiAgZnVuY3Rpb24gSGlzdG9yeVJvdXRlcihfcmVmNikge1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZnV0dXJlLFxuICAgICAgaGlzdG9yeVxuICAgIH0gPSBfcmVmNjtcbiAgICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSh7XG4gICAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgICB9KTtcbiAgICBsZXQge1xuICAgICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gICAgfSA9IGZ1dHVyZSB8fCB7fTtcbiAgICBsZXQgc2V0U3RhdGUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKG5ld1N0YXRlID0+IHtcbiAgICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKSA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyZWFjdFJvdXRlci5Sb3V0ZXIsIHtcbiAgICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgICB9KTtcbiAgfVxuICB7XG4gICAgSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xuICB9XG4gIGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgYDxhPmAuXG4gICAqL1xuICBjb25zdCBMaW5rID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuZm9yd2FyZFJlZihmdW5jdGlvbiBMaW5rV2l0aFJlZihfcmVmNywgcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgICAgb25DbGljayxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIHJlbG9hZERvY3VtZW50LFxuICAgICAgICByZXBsYWNlLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0byxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgICAgfSA9IF9yZWY3LFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY3LCBfZXhjbHVkZWQpO1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZVxuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQocmVhY3RSb3V0ZXIuVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcblxuICAgIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIGFic29sdXRlIFVSTHNcbiAgICBsZXQgYWJzb2x1dGVIcmVmO1xuICAgIGxldCBpc0V4dGVybmFsID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiAmJiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh0bykpIHtcbiAgICAgIC8vIFJlbmRlciB0aGUgYWJzb2x1dGUgaHJlZiBzZXJ2ZXItIGFuZCBjbGllbnQtc2lkZVxuICAgICAgYWJzb2x1dGVIcmVmID0gdG87XG5cbiAgICAgIC8vIE9ubHkgY2hlY2sgZm9yIGV4dGVybmFsIG9yaWdpbnMgY2xpZW50LXNpZGVcbiAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgY3VycmVudFVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgIGxldCB0YXJnZXRVcmwgPSB0by5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyB0bykgOiBuZXcgVVJMKHRvKTtcbiAgICAgICAgICBsZXQgcGF0aCA9IHJvdXRlci5zdHJpcEJhc2VuYW1lKHRhcmdldFVybC5wYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgICAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFN0cmlwIHRoZSBwcm90b2NvbC9vcmlnaW4vYmFzZW5hbWUgZm9yIHNhbWUtb3JpZ2luIGFic29sdXRlIFVSTHNcbiAgICAgICAgICAgIHRvID0gcGF0aCArIHRhcmdldFVybC5zZWFyY2ggKyB0YXJnZXRVcmwuaGFzaDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNFeHRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gV2UgY2FuJ3QgZG8gZXh0ZXJuYWwgVVJMIGRldGVjdGlvbiB3aXRob3V0IGEgdmFsaWQgVVJMXG4gICAgICAgICAgcm91dGVyLlVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIjxMaW5rIHRvPVxcXCJcIiArIHRvICsgXCJcXFwiPiBjb250YWlucyBhbiBpbnZhbGlkIFVSTCB3aGljaCB3aWxsIHByb2JhYmx5IGJyZWFrIFwiICsgXCJ3aGVuIGNsaWNrZWQgLSBwbGVhc2UgdXBkYXRlIHRvIGEgdmFsaWQgVVJMIHBhdGguXCIpIDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIHJlbGF0aXZlIFVSTHNcbiAgICBsZXQgaHJlZiA9IHJlYWN0Um91dGVyLnVzZUhyZWYodG8sIHtcbiAgICAgIHJlbGF0aXZlXG4gICAgfSk7XG4gICAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50XG4gICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICAgIGhyZWY6IGFic29sdXRlSHJlZiB8fCBocmVmLFxuICAgICAgICBvbkNsaWNrOiBpc0V4dGVybmFsIHx8IHJlbG9hZERvY3VtZW50ID8gb25DbGljayA6IGhhbmRsZUNsaWNrLFxuICAgICAgICByZWY6IHJlZixcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pKVxuICAgICk7XG4gIH0pO1xuICB7XG4gICAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xuICB9XG4gIC8qKlxuICAgKiBBIGA8TGluaz5gIHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICAgKi9cbiAgY29uc3QgTmF2TGluayA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmZvcndhcmRSZWYoZnVuY3Rpb24gTmF2TGlua1dpdGhSZWYoX3JlZjgsIHJlZikge1xuICAgIGxldCB7XG4gICAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50UHJvcCA9IFwicGFnZVwiLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lUHJvcCA9IFwiXCIsXG4gICAgICAgIGVuZCA9IGZhbHNlLFxuICAgICAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgICAgICB0byxcbiAgICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9ID0gX3JlZjgsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjgsIF9leGNsdWRlZDIpO1xuICAgIGxldCBwYXRoID0gcmVhY3RSb3V0ZXIudXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgICByZWxhdGl2ZTogcmVzdC5yZWxhdGl2ZVxuICAgIH0pO1xuICAgIGxldCBsb2NhdGlvbiA9IHJlYWN0Um91dGVyLnVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IHJvdXRlclN0YXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KHJlYWN0Um91dGVyLlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgICBsZXQge1xuICAgICAgbmF2aWdhdG9yXG4gICAgfSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChyZWFjdFJvdXRlci5VTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCBpc1RyYW5zaXRpb25pbmcgPSByb3V0ZXJTdGF0ZSAhPSBudWxsICYmXG4gICAgLy8gQ29uZGl0aW9uYWwgdXNhZ2UgaXMgT0sgaGVyZSBiZWNhdXNlIHRoZSB1c2FnZSBvZiBhIGRhdGEgcm91dGVyIGlzIHN0YXRpY1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUocGF0aCkgJiYgdW5zdGFibGVfdmlld1RyYW5zaXRpb24gPT09IHRydWU7XG4gICAgbGV0IHRvUGF0aG5hbWUgPSBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24ocGF0aCkucGF0aG5hbWUgOiBwYXRoLnBhdGhuYW1lO1xuICAgIGxldCBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgbGV0IG5leHRMb2NhdGlvblBhdGhuYW1lID0gcm91dGVyU3RhdGUgJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbiAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uID8gcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbi5wYXRobmFtZSA6IG51bGw7XG4gICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSBuZXh0TG9jYXRpb25QYXRobmFtZSA/IG5leHRMb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgbGV0IGlzQWN0aXZlID0gbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIGxvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBsb2NhdGlvblBhdGhuYW1lLmNoYXJBdCh0b1BhdGhuYW1lLmxlbmd0aCkgPT09IFwiL1wiO1xuICAgIGxldCBpc1BlbmRpbmcgPSBuZXh0TG9jYXRpb25QYXRobmFtZSAhPSBudWxsICYmIChuZXh0TG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIG5leHRMb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuY2hhckF0KHRvUGF0aG5hbWUubGVuZ3RoKSA9PT0gXCIvXCIpO1xuICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgIGlzQWN0aXZlLFxuICAgICAgaXNQZW5kaW5nLFxuICAgICAgaXNUcmFuc2l0aW9uaW5nXG4gICAgfTtcbiAgICBsZXQgYXJpYUN1cnJlbnQgPSBpc0FjdGl2ZSA/IGFyaWFDdXJyZW50UHJvcCA6IHVuZGVmaW5lZDtcbiAgICBsZXQgY2xhc3NOYW1lO1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lUHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWVQcm9wKHJlbmRlclByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGNsYXNzTmFtZSBwcm9wIGlzIG5vdCBhIGZ1bmN0aW9uLCB3ZSB1c2UgYSBkZWZhdWx0IGBhY3RpdmVgXG4gICAgICAvLyBjbGFzcyBmb3IgPE5hdkxpbmsgLz5zIHRoYXQgYXJlIGFjdGl2ZS4gSW4gdjUgYGFjdGl2ZWAgd2FzIHRoZSBkZWZhdWx0XG4gICAgICAvLyB2YWx1ZSBmb3IgYGFjdGl2ZUNsYXNzTmFtZWAsIGJ1dCB3ZSBhcmUgcmVtb3ZpbmcgdGhhdCBBUEkgYW5kIGNhbiBzdGlsbFxuICAgICAgLy8gdXNlIHRoZSBvbGQgZGVmYXVsdCBiZWhhdmlvciBmb3IgYSBjbGVhbmVyIHVwZ3JhZGUgcGF0aCBhbmQga2VlcCB0aGVcbiAgICAgIC8vIHNpbXBsZSBzdHlsaW5nIHJ1bGVzIHdvcmtpbmcgYXMgdGhleSBjdXJyZW50bHkgZG8uXG4gICAgICBjbGFzc05hbWUgPSBbY2xhc3NOYW1lUHJvcCwgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbCwgaXNQZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBudWxsLCBpc1RyYW5zaXRpb25pbmcgPyBcInRyYW5zaXRpb25pbmdcIiA6IG51bGxdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgbGV0IHN0eWxlID0gdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVQcm9wKHJlbmRlclByb3BzKSA6IHN0eWxlUHJvcDtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChMaW5rLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnQsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgdG86IHRvLFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb246IHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gICAgfSksIHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4ocmVuZGVyUHJvcHMpIDogY2hpbGRyZW4pO1xuICB9KTtcbiAge1xuICAgIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbiAgfVxuICAvKipcbiAgICogQSBgQHJlbWl4LXJ1bi9yb3V0ZXJgLWF3YXJlIGA8Zm9ybT5gLiBJdCBiZWhhdmVzIGxpa2UgYSBub3JtYWwgZm9ybSBleGNlcHRcbiAgICogdGhhdCB0aGUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2VydmVyIGlzIHdpdGggYGZldGNoYCBpbnN0ZWFkIG9mIG5ldyBkb2N1bWVudFxuICAgKiByZXF1ZXN0cywgYWxsb3dpbmcgY29tcG9uZW50cyB0byBhZGQgbmljZXIgVVggdG8gdGhlIHBhZ2UgYXMgdGhlIGZvcm0gaXNcbiAgICogc3VibWl0dGVkIGFuZCByZXR1cm5zIHdpdGggZGF0YS5cbiAgICovXG4gIGNvbnN0IEZvcm0gPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdCgpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEZvcm1JbXBsLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHN1Ym1pdDogc3VibWl0LFxuICAgICAgcmVmOiByZWZcbiAgICB9KSk7XG4gIH0pO1xuICB7XG4gICAgRm9ybS5kaXNwbGF5TmFtZSA9IFwiRm9ybVwiO1xuICB9XG4gIGNvbnN0IEZvcm1JbXBsID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuZm9yd2FyZFJlZigoX3JlZjksIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGxldCB7XG4gICAgICAgIHJlbG9hZERvY3VtZW50LFxuICAgICAgICByZXBsYWNlLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZCxcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBvblN1Ym1pdCxcbiAgICAgICAgc3VibWl0LFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgICAgfSA9IF9yZWY5LFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmOSwgX2V4Y2x1ZGVkMyk7XG4gICAgbGV0IGZvcm1NZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIiA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcbiAgICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7XG4gICAgICByZWxhdGl2ZVxuICAgIH0pO1xuICAgIGxldCBzdWJtaXRIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgb25TdWJtaXQgJiYgb25TdWJtaXQoZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBsZXQgc3VibWl0dGVyID0gZXZlbnQubmF0aXZlRXZlbnQuc3VibWl0dGVyO1xuICAgICAgbGV0IHN1Ym1pdE1ldGhvZCA9IChzdWJtaXR0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHN1Ym1pdHRlci5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpKSB8fCBtZXRob2Q7XG4gICAgICBzdWJtaXQoc3VibWl0dGVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQsIHtcbiAgICAgICAgbWV0aG9kOiBzdWJtaXRNZXRob2QsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImZvcm1cIiwgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICBtZXRob2Q6IGZvcm1NZXRob2QsXG4gICAgICBhY3Rpb246IGZvcm1BY3Rpb24sXG4gICAgICBvblN1Ym1pdDogcmVsb2FkRG9jdW1lbnQgPyBvblN1Ym1pdCA6IHN1Ym1pdEhhbmRsZXJcbiAgICB9LCBwcm9wcykpO1xuICB9KTtcbiAge1xuICAgIEZvcm1JbXBsLmRpc3BsYXlOYW1lID0gXCJGb3JtSW1wbFwiO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGNvbXBvbmVudCB3aWxsIGVtdWxhdGUgdGhlIGJyb3dzZXIncyBzY3JvbGwgcmVzdG9yYXRpb24gb24gbG9jYXRpb25cbiAgICogY2hhbmdlcy5cbiAgICovXG4gIGZ1bmN0aW9uIFNjcm9sbFJlc3RvcmF0aW9uKF9yZWYxMCkge1xuICAgIGxldCB7XG4gICAgICBnZXRLZXksXG4gICAgICBzdG9yYWdlS2V5XG4gICAgfSA9IF9yZWYxMDtcbiAgICB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XG4gICAgICBnZXRLZXksXG4gICAgICBzdG9yYWdlS2V5XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAge1xuICAgIFNjcm9sbFJlc3RvcmF0aW9uLmRpc3BsYXlOYW1lID0gXCJTY3JvbGxSZXN0b3JhdGlvblwiO1xuICB9XG4gIC8vI2VuZHJlZ2lvblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vI3JlZ2lvbiBIb29rc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICB2YXIgRGF0YVJvdXRlckhvb2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKERhdGFSb3V0ZXJIb29rKSB7XG4gICAgRGF0YVJvdXRlckhvb2tbXCJVc2VTY3JvbGxSZXN0b3JhdGlvblwiXSA9IFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIjtcbiAgICBEYXRhUm91dGVySG9va1tcIlVzZVN1Ym1pdFwiXSA9IFwidXNlU3VibWl0XCI7XG4gICAgRGF0YVJvdXRlckhvb2tbXCJVc2VTdWJtaXRGZXRjaGVyXCJdID0gXCJ1c2VTdWJtaXRGZXRjaGVyXCI7XG4gICAgRGF0YVJvdXRlckhvb2tbXCJVc2VGZXRjaGVyXCJdID0gXCJ1c2VGZXRjaGVyXCI7XG4gICAgRGF0YVJvdXRlckhvb2tbXCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlXCJdID0gXCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlXCI7XG4gICAgcmV0dXJuIERhdGFSb3V0ZXJIb29rO1xuICB9KERhdGFSb3V0ZXJIb29rIHx8IHt9KTtcbiAgdmFyIERhdGFSb3V0ZXJTdGF0ZUhvb2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlRmV0Y2hlcnNcIl0gPSBcInVzZUZldGNoZXJzXCI7XG4gICAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVNjcm9sbFJlc3RvcmF0aW9uXCJdID0gXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiO1xuICAgIHJldHVybiBEYXRhUm91dGVyU3RhdGVIb29rO1xuICB9KERhdGFSb3V0ZXJTdGF0ZUhvb2sgfHwge30pO1xuICBmdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSB7XG4gICAgcmV0dXJuIGhvb2tOYW1lICsgXCIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5cIjtcbiAgfVxuICBmdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZSkge1xuICAgIGxldCBjdHggPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQocmVhY3RSb3V0ZXIuVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0KTtcbiAgICAhY3R4ID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSAgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuICBmdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWUpIHtcbiAgICBsZXQgc3RhdGUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQocmVhY3RSb3V0ZXIuVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICAgICFzdGF0ZSA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgIDogdm9pZCAwO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjbGljayBiZWhhdmlvciBmb3Igcm91dGVyIGA8TGluaz5gIGNvbXBvbmVudHMuIFRoaXMgaXMgdXNlZnVsIGlmXG4gICAqIHlvdSBuZWVkIHRvIGNyZWF0ZSBjdXN0b20gYDxMaW5rPmAgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGNsaWNrIGJlaGF2aW9yIHdlXG4gICAqIHVzZSBpbiBvdXIgZXhwb3J0ZWQgYDxMaW5rPmAuXG4gICAqL1xuICBmdW5jdGlvbiB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCBfdGVtcCkge1xuICAgIGxldCB7XG4gICAgICB0YXJnZXQsXG4gICAgICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgICAgIHN0YXRlLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgICBsZXQgbmF2aWdhdGUgPSByZWFjdFJvdXRlci51c2VOYXZpZ2F0ZSgpO1xuICAgIGxldCBsb2NhdGlvbiA9IHJlYWN0Um91dGVyLnVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IHBhdGggPSByZWFjdFJvdXRlci51c2VSZXNvbHZlZFBhdGgodG8sIHtcbiAgICAgIHJlbGF0aXZlXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKHNob3VsZFByb2Nlc3NMaW5rQ2xpY2soZXZlbnQsIHRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBJZiB0aGUgVVJMIGhhc24ndCBjaGFuZ2VkLCBhIHJlZ3VsYXIgPGE+IHdpbGwgZG8gYSByZXBsYWNlIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gYSBwdXNoLCBzbyBkbyB0aGUgc2FtZSBoZXJlIHVubGVzcyB0aGUgcmVwbGFjZSBwcm9wIGlzIGV4cGxpY2l0bHkgc2V0XG4gICAgICAgIGxldCByZXBsYWNlID0gcmVwbGFjZVByb3AgIT09IHVuZGVmaW5lZCA/IHJlcGxhY2VQcm9wIDogcmVhY3RSb3V0ZXIuY3JlYXRlUGF0aChsb2NhdGlvbikgPT09IHJlYWN0Um91dGVyLmNyZWF0ZVBhdGgocGF0aCk7XG4gICAgICAgIG5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgcmVwbGFjZSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2xvY2F0aW9uLCBuYXZpZ2F0ZSwgcGF0aCwgcmVwbGFjZVByb3AsIHN0YXRlLCB0YXJnZXQsIHRvLCBwcmV2ZW50U2Nyb2xsUmVzZXQsIHJlbGF0aXZlLCB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNlYXJjaCBwYXJhbWV0ZXJzIHZpYSB0aGVcbiAgICogVVJMU2VhcmNoUGFyYW1zIGludGVyZmFjZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkge1xuICAgIHJvdXRlci5VTlNBRkVfd2FybmluZyh0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSBcInVuZGVmaW5lZFwiLCBcIllvdSBjYW5ub3QgdXNlIHRoZSBgdXNlU2VhcmNoUGFyYW1zYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IFwiICsgXCJzdXBwb3J0IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IEludGVybmV0IFwiICsgXCJFeHBsb3JlciAxMSwgd2UgcmVjb21tZW5kIHlvdSBsb2FkIGEgcG9seWZpbGwgc3VjaCBhcyBcIiArIFwiaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXFxuXFxuXCIgKyBcIklmIHlvdSdyZSB1bnN1cmUgaG93IHRvIGxvYWQgcG9seWZpbGxzLCB3ZSByZWNvbW1lbmQgeW91IGNoZWNrIG91dCBcIiArIFwiaHR0cHM6Ly9wb2x5ZmlsbC5pby92My8gd2hpY2ggcHJvdmlkZXMgc29tZSByZWNvbW1lbmRhdGlvbnMgYWJvdXQgaG93IFwiICsgXCJ0byBsb2FkIHBvbHlmaWxscyBvbmx5IGZvciB1c2VycyB0aGF0IG5lZWQgdGhlbSwgaW5zdGVhZCBvZiBmb3IgZXZlcnkgXCIgKyBcInVzZXIuXCIpIDtcbiAgICBsZXQgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKGNyZWF0ZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkpO1xuICAgIGxldCBoYXNTZXRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihmYWxzZSk7XG4gICAgbGV0IGxvY2F0aW9uID0gcmVhY3RSb3V0ZXIudXNlTG9jYXRpb24oKTtcbiAgICBsZXQgc2VhcmNoUGFyYW1zID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKCgpID0+XG4gICAgLy8gT25seSBtZXJnZSBpbiB0aGUgZGVmYXVsdHMgaWYgd2UgaGF2ZW4ndCB5ZXQgY2FsbGVkIHNldFNlYXJjaFBhcmFtcy5cbiAgICAvLyBPbmNlIHdlIGNhbGwgdGhhdCB3ZSB3YW50IHRob3NlIHRvIHRha2UgcHJlY2VkZW5jZSwgb3RoZXJ3aXNlIHlvdSBjYW4ndFxuICAgIC8vIHJlbW92ZSBhIHBhcmFtIHdpdGggc2V0U2VhcmNoUGFyYW1zKHt9KSBpZiBpdCBoYXMgYW4gaW5pdGlhbCB2YWx1ZVxuICAgIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKGxvY2F0aW9uLnNlYXJjaCwgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPyBudWxsIDogZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50KSwgW2xvY2F0aW9uLnNlYXJjaF0pO1xuICAgIGxldCBuYXZpZ2F0ZSA9IHJlYWN0Um91dGVyLnVzZU5hdmlnYXRlKCk7XG4gICAgbGV0IHNldFNlYXJjaFBhcmFtcyA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soKG5leHRJbml0LCBuYXZpZ2F0ZU9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IG5ld1NlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh0eXBlb2YgbmV4dEluaXQgPT09IFwiZnVuY3Rpb25cIiA/IG5leHRJbml0KHNlYXJjaFBhcmFtcykgOiBuZXh0SW5pdCk7XG4gICAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBuYXZpZ2F0ZShcIj9cIiArIG5ld1NlYXJjaFBhcmFtcywgbmF2aWdhdGVPcHRpb25zKTtcbiAgICB9LCBbbmF2aWdhdGUsIHNlYXJjaFBhcmFtc10pO1xuICAgIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdHMgYSBIVE1MIGA8Zm9ybT5gIHRvIHRoZSBzZXJ2ZXIgd2l0aG91dCByZWxvYWRpbmcgdGhlIHBhZ2UuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTdWJtaXRzIGEgZmV0Y2hlciBgPGZvcm0+YCB0byB0aGUgc2VydmVyIHdpdGhvdXQgcmVsb2FkaW5nIHRoZSBwYWdlLlxuICAgKi9cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUNsaWVudFNpZGVTdWJtaXNzaW9uKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBhcmUgY2FsbGluZyBzdWJtaXQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLiBcIiArIFwiVHJ5IGNhbGxpbmcgc3VibWl0IHdpdGhpbiBhIGB1c2VFZmZlY3RgIG9yIGNhbGxiYWNrIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IHN1Ym1pdCBhIGZvcm0gKG9yXG4gICAqIHNvbWUgYXJiaXRyYXJ5IGRhdGEpIHRvIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB1c2VTdWJtaXQoKSB7XG4gICAgbGV0IHtcbiAgICAgIHJvdXRlclxuICAgIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VTdWJtaXQpO1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZVxuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQocmVhY3RSb3V0ZXIuVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgICBsZXQgY3VycmVudFJvdXRlSWQgPSByZWFjdFJvdXRlci5VTlNBRkVfdXNlUm91dGVJZCgpO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgdmFsaWRhdGVDbGllbnRTaWRlU3VibWlzc2lvbigpO1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGVuY1R5cGUsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBib2R5XG4gICAgICB9ID0gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKHRhcmdldCwgYmFzZW5hbWUpO1xuICAgICAgcm91dGVyLm5hdmlnYXRlKG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgZm9ybU1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgbWV0aG9kLFxuICAgICAgICBmb3JtRW5jVHlwZTogb3B0aW9ucy5lbmNUeXBlIHx8IGVuY1R5cGUsXG4gICAgICAgIHJlcGxhY2U6IG9wdGlvbnMucmVwbGFjZSxcbiAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgIGZyb21Sb3V0ZUlkOiBjdXJyZW50Um91dGVJZCxcbiAgICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb246IG9wdGlvbnMudW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICAgIH0pO1xuICAgIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBjdXJyZW50Um91dGVJZF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltcGxlbWVudGF0aW9uIGZvciBmZXRjaGVyLnN1Ym1pdFxuICAgKi9cbiAgZnVuY3Rpb24gdXNlU3VibWl0RmV0Y2hlcihmZXRjaGVyS2V5LCBmZXRjaGVyUm91dGVJZCkge1xuICAgIGxldCB7XG4gICAgICByb3V0ZXI6IHJvdXRlciQxXG4gICAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVN1Ym1pdEZldGNoZXIpO1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZVxuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQocmVhY3RSb3V0ZXIuVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24oKTtcbiAgICAgIGxldCB7XG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBlbmNUeXBlLFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgYm9keVxuICAgICAgfSA9IGdldEZvcm1TdWJtaXNzaW9uSW5mbyh0YXJnZXQsIGJhc2VuYW1lKTtcbiAgICAgICEoZmV0Y2hlclJvdXRlSWQgIT0gbnVsbCkgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgdXNlRmV0Y2hlcigpXCIpICA6IHZvaWQgMDtcbiAgICAgIHJvdXRlciQxLmZldGNoKGZldGNoZXJLZXksIGZldGNoZXJSb3V0ZUlkLCBvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IG1ldGhvZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlXG4gICAgICB9KTtcbiAgICB9LCBbcm91dGVyJDEsIGJhc2VuYW1lLCBmZXRjaGVyS2V5LCBmZXRjaGVyUm91dGVJZF0pO1xuICB9XG5cbiAgLy8gdjc6IEV2ZW50dWFsbHkgd2Ugc2hvdWxkIGRlcHJlY2F0ZSB0aGlzIGVudGlyZWx5IGluIGZhdm9yIG9mIHVzaW5nIHRoZVxuICAvLyByb3V0ZXIgbWV0aG9kIGRpcmVjdGx5P1xuICBmdW5jdGlvbiB1c2VGb3JtQWN0aW9uKGFjdGlvbiwgX3RlbXAyKSB7XG4gICAgbGV0IHtcbiAgICAgIHJlbGF0aXZlXG4gICAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VuYW1lXG4gICAgfSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChyZWFjdFJvdXRlci5VTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCByb3V0ZUNvbnRleHQgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQocmVhY3RSb3V0ZXIuVU5TQUZFX1JvdXRlQ29udGV4dCk7XG4gICAgIXJvdXRlQ29udGV4dCA/IHJvdXRlci5VTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZvcm1BY3Rpb24gbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKSAgOiB2b2lkIDA7XG4gICAgbGV0IFttYXRjaF0gPSByb3V0ZUNvbnRleHQubWF0Y2hlcy5zbGljZSgtMSk7XG4gICAgLy8gU2hhbGxvdyBjbG9uZSBwYXRoIHNvIHdlIGNhbiBtb2RpZnkgaXQgYmVsb3csIG90aGVyd2lzZSB3ZSBtb2RpZnkgdGhlXG4gICAgLy8gb2JqZWN0IHJlZmVyZW5jZWQgYnkgdXNlTWVtbyBpbnNpZGUgdXNlUmVzb2x2ZWRQYXRoXG4gICAgbGV0IHBhdGggPSBfZXh0ZW5kcyh7fSwgcmVhY3RSb3V0ZXIudXNlUmVzb2x2ZWRQYXRoKGFjdGlvbiA/IGFjdGlvbiA6IFwiLlwiLCB7XG4gICAgICByZWxhdGl2ZVxuICAgIH0pKTtcblxuICAgIC8vIFByZXZpb3VzbHkgd2Ugc2V0IHRoZSBkZWZhdWx0IGFjdGlvbiB0byBcIi5cIi4gVGhlIHByb2JsZW0gd2l0aCB0aGlzIGlzIHRoYXRcbiAgICAvLyBgdXNlUmVzb2x2ZWRQYXRoKFwiLlwiKWAgZXhjbHVkZXMgc2VhcmNoIHBhcmFtcyBvZiB0aGUgcmVzb2x2ZWQgVVJMLiBUaGlzIGlzXG4gICAgLy8gdGhlIGludGVuZGVkIGJlaGF2aW9yIG9mIHdoZW4gXCIuXCIgaXMgc3BlY2lmaWNhbGx5IHByb3ZpZGVkIGFzXG4gICAgLy8gdGhlIGZvcm0gYWN0aW9uLCBidXQgaW5jb25zaXN0ZW50IHcvIGJyb3dzZXJzIHdoZW4gdGhlIGFjdGlvbiBpcyBvbWl0dGVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVtaXgvaXNzdWVzLzkyN1xuICAgIGxldCBsb2NhdGlvbiA9IHJlYWN0Um91dGVyLnVzZUxvY2F0aW9uKCk7XG4gICAgaWYgKGFjdGlvbiA9PSBudWxsKSB7XG4gICAgICAvLyBTYWZlIHRvIHdyaXRlIHRvIHRoaXMgZGlyZWN0bHkgaGVyZSBzaW5jZSBpZiBhY3Rpb24gd2FzIHVuZGVmaW5lZCwgd2VcbiAgICAgIC8vIHdvdWxkIGhhdmUgY2FsbGVkIHVzZVJlc29sdmVkUGF0aChcIi5cIikgd2hpY2ggd2lsbCBuZXZlciBpbmNsdWRlIGEgc2VhcmNoXG4gICAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcblxuICAgICAgLy8gV2hlbiBncmFiYmluZyBzZWFyY2ggcGFyYW1zIGZyb20gdGhlIFVSTCwgcmVtb3ZlIHRoZSBhdXRvbWF0aWNhbGx5XG4gICAgICAvLyBpbnNlcnRlZCA/aW5kZXggcGFyYW0gc28gd2UgbWF0Y2ggdGhlIHVzZVJlc29sdmVkUGF0aCBzZWFyY2ggYmVoYXZpb3JcbiAgICAgIC8vIHdoaWNoIHdvdWxkIG5vdCBpbmNsdWRlID9pbmRleFxuICAgICAgaWYgKG1hdGNoLnJvdXRlLmluZGV4KSB7XG4gICAgICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGguc2VhcmNoKTtcbiAgICAgICAgcGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICAgICAgICBwYXRoLnNlYXJjaCA9IHBhcmFtcy50b1N0cmluZygpID8gXCI/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoIWFjdGlvbiB8fCBhY3Rpb24gPT09IFwiLlwiKSAmJiBtYXRjaC5yb3V0ZS5pbmRleCkge1xuICAgICAgcGF0aC5zZWFyY2ggPSBwYXRoLnNlYXJjaCA/IHBhdGguc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIikgOiBcIj9pbmRleFwiO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgICAvLyB0byBjcmVhdGluZyB0aGUgZm9ybSBhY3Rpb24uICBJZiB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIGp1c3QgdXNlXG4gICAgLy8gdGhlIHJhdyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlXG4gICAgLy8gcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaCBvbiByb290IGFjdGlvbnNcbiAgICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IHJvdXRlci5qb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgfVxuICAgIHJldHVybiByZWFjdFJvdXRlci5jcmVhdGVQYXRoKHBhdGgpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUZldGNoZXJGb3JtKGZldGNoZXJLZXksIHJvdXRlSWQpIHtcbiAgICBsZXQgRmV0Y2hlckZvcm0gPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgICBsZXQgc3VibWl0ID0gdXNlU3VibWl0RmV0Y2hlcihmZXRjaGVyS2V5LCByb3V0ZUlkKTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEZvcm1JbXBsLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgcmVmOiByZWYsXG4gICAgICAgIHN1Ym1pdDogc3VibWl0XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAge1xuICAgICAgRmV0Y2hlckZvcm0uZGlzcGxheU5hbWUgPSBcImZldGNoZXIuRm9ybVwiO1xuICAgIH1cbiAgICByZXR1cm4gRmV0Y2hlckZvcm07XG4gIH1cbiAgbGV0IGZldGNoZXJJZCA9IDA7XG4gIC8vIFRPRE86ICh2NykgQ2hhbmdlIHRoZSB1c2VGZXRjaGVyIGdlbmVyaWMgZGVmYXVsdCBmcm9tIGBhbnlgIHRvIGB1bmtub3duYFxuICAvKipcbiAgICogSW50ZXJhY3RzIHdpdGggcm91dGUgbG9hZGVycyBhbmQgYWN0aW9ucyB3aXRob3V0IGNhdXNpbmcgYSBuYXZpZ2F0aW9uLiBHcmVhdFxuICAgKiBmb3IgYW55IGludGVyYWN0aW9uIHRoYXQgc3RheXMgb24gdGhlIHNhbWUgcGFnZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVzZUZldGNoZXIoKSB7XG4gICAgdmFyIF9yb3V0ZSRtYXRjaGVzO1xuICAgIGxldCB7XG4gICAgICByb3V0ZXI6IHJvdXRlciQxXG4gICAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUZldGNoZXIpO1xuICAgIGxldCByb3V0ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChyZWFjdFJvdXRlci5VTlNBRkVfUm91dGVDb250ZXh0KTtcbiAgICAhcm91dGUgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIikgIDogdm9pZCAwO1xuICAgIGxldCByb3V0ZUlkID0gKF9yb3V0ZSRtYXRjaGVzID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlJG1hdGNoZXMucm91dGUuaWQ7XG4gICAgIShyb3V0ZUlkICE9IG51bGwpID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwidXNlRmV0Y2hlciBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXFxcImlkXFxcIlwiKSAgOiB2b2lkIDA7XG4gICAgbGV0IFtmZXRjaGVyS2V5XSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoKCkgPT4gU3RyaW5nKCsrZmV0Y2hlcklkKSk7XG4gICAgbGV0IFtGb3JtXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoKCkgPT4ge1xuICAgICAgIXJvdXRlSWQgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5Gb3JtKClcIikgIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGNyZWF0ZUZldGNoZXJGb3JtKGZldGNoZXJLZXksIHJvdXRlSWQpO1xuICAgIH0pO1xuICAgIGxldCBbbG9hZF0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKCgpID0+IGhyZWYgPT4ge1xuICAgICAgIXJvdXRlciQxID8gcm91dGVyLlVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiTm8gcm91dGVyIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5sb2FkKClcIikgIDogdm9pZCAwO1xuICAgICAgIXJvdXRlSWQgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5sb2FkKClcIikgIDogdm9pZCAwO1xuICAgICAgcm91dGVyJDEuZmV0Y2goZmV0Y2hlcktleSwgcm91dGVJZCwgaHJlZik7XG4gICAgfSk7XG4gICAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdEZldGNoZXIoZmV0Y2hlcktleSwgcm91dGVJZCk7XG4gICAgbGV0IGZldGNoZXIgPSByb3V0ZXIkMS5nZXRGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgIGxldCBmZXRjaGVyV2l0aENvbXBvbmVudHMgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4gX2V4dGVuZHMoe1xuICAgICAgRm9ybSxcbiAgICAgIHN1Ym1pdCxcbiAgICAgIGxvYWRcbiAgICB9LCBmZXRjaGVyKSwgW2ZldGNoZXIsIEZvcm0sIHN1Ym1pdCwgbG9hZF0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIElzIHRoaXMgYnVzdGVkIHdoZW4gdGhlIFJlYWN0IHRlYW0gZ2V0cyByZWFsIHdlaXJkIGFuZCBjYWxscyBlZmZlY3RzXG4gICAgICAvLyB0d2ljZSBvbiBtb3VudD8gIFdlIHJlYWxseSBqdXN0IG5lZWQgdG8gZ2FyYmFnZSBjb2xsZWN0IGhlcmUgd2hlbiB0aGlzXG4gICAgICAvLyBmZXRjaGVyIGlzIG5vIGxvbmdlciBhcm91bmQuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIXJvdXRlciQxKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gcm91dGVyIGF2YWlsYWJsZSB0byBjbGVhbiB1cCBmcm9tIHVzZUZldGNoZXIoKVwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcm91dGVyJDEuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICAgIH07XG4gICAgfSwgW3JvdXRlciQxLCBmZXRjaGVyS2V5XSk7XG4gICAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhbGwgZmV0Y2hlcnMgY3VycmVudGx5IG9uIHRoZSBwYWdlLiBVc2VmdWwgZm9yIGxheW91dHMgYW5kIHBhcmVudFxuICAgKiByb3V0ZXMgdGhhdCBuZWVkIHRvIHByb3ZpZGUgcGVuZGluZy9vcHRpbWlzdGljIFVJIHJlZ2FyZGluZyB0aGUgZmV0Y2guXG4gICAqL1xuICBmdW5jdGlvbiB1c2VGZXRjaGVycygpIHtcbiAgICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VGZXRjaGVycyk7XG4gICAgcmV0dXJuIFsuLi5zdGF0ZS5mZXRjaGVycy52YWx1ZXMoKV07XG4gIH1cbiAgY29uc3QgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZID0gXCJyZWFjdC1yb3V0ZXItc2Nyb2xsLXBvc2l0aW9uc1wiO1xuICBsZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSB7fTtcblxuICAvKipcbiAgICogV2hlbiByZW5kZXJlZCBpbnNpZGUgYSBSb3V0ZXJQcm92aWRlciwgd2lsbCByZXN0b3JlIHNjcm9sbCBwb3NpdGlvbnMgb24gbmF2aWdhdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIHVzZVNjcm9sbFJlc3RvcmF0aW9uKF90ZW1wMykge1xuICAgIGxldCB7XG4gICAgICBnZXRLZXksXG4gICAgICBzdG9yYWdlS2V5XG4gICAgfSA9IF90ZW1wMyA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDM7XG4gICAgbGV0IHtcbiAgICAgIHJvdXRlcjogcm91dGVyJDFcbiAgICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb24pO1xuICAgIGxldCB7XG4gICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb24sXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb24pO1xuICAgIGxldCB7XG4gICAgICBiYXNlbmFtZVxuICAgIH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQocmVhY3RSb3V0ZXIuVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgICBsZXQgbG9jYXRpb24gPSByZWFjdFJvdXRlci51c2VMb2NhdGlvbigpO1xuICAgIGxldCBtYXRjaGVzID0gcmVhY3RSb3V0ZXIudXNlTWF0Y2hlcygpO1xuICAgIGxldCBuYXZpZ2F0aW9uID0gcmVhY3RSb3V0ZXIudXNlTmF2aWdhdGlvbigpO1xuXG4gICAgLy8gVHJpZ2dlciBtYW51YWwgc2Nyb2xsIHJlc3RvcmF0aW9uIHdoaWxlIHdlJ3JlIGFjdGl2ZVxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgICB9O1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFNhdmUgcG9zaXRpb25zIG9uIHBhZ2VoaWRlXG4gICAgdXNlUGFnZUhpZGUoUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBpZiAobmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgbGV0IGtleSA9IChnZXRLZXkgPyBnZXRLZXkobG9jYXRpb24sIG1hdGNoZXMpIDogbnVsbCkgfHwgbG9jYXRpb24ua2V5O1xuICAgICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldID0gd2luZG93LnNjcm9sbFk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzYXZlZFNjcm9sbFBvc2l0aW9ucykpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcm91dGVyLlVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIkZhaWxlZCB0byBzYXZlIHNjcm9sbCBwb3NpdGlvbnMgaW4gc2Vzc2lvblN0b3JhZ2UsIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB3aWxsIG5vdCB3b3JrIHByb3Blcmx5IChcIiArIGVycm9yICsgXCIpLlwiKSA7XG4gICAgICB9XG4gICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICAgIH0sIFtzdG9yYWdlS2V5LCBnZXRLZXksIG5hdmlnYXRpb24uc3RhdGUsIGxvY2F0aW9uLCBtYXRjaGVzXSkpO1xuXG4gICAgLy8gUmVhZCBpbiBhbnkgc2F2ZWQgc2Nyb2xsIGxvY2F0aW9uc1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgUmVhY3RfX25hbWVzcGFjZS51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSk7XG4gICAgICAgICAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gSlNPTi5wYXJzZShzZXNzaW9uUG9zaXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBuby1vcCwgdXNlIGRlZmF1bHQgZW1wdHkgb2JqZWN0XG4gICAgICAgIH1cbiAgICAgIH0sIFtzdG9yYWdlS2V5XSk7XG5cbiAgICAgIC8vIEVuYWJsZSBzY3JvbGwgcmVzdG9yYXRpb24gaW4gdGhlIHJvdXRlclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBnZXRLZXlXaXRob3V0QmFzZW5hbWUgPSBnZXRLZXkgJiYgYmFzZW5hbWUgIT09IFwiL1wiID8gKGxvY2F0aW9uLCBtYXRjaGVzKSA9PiBnZXRLZXkoIC8vIFN0cmlwIHRoZSBiYXNlbmFtZSB0byBtYXRjaCB1c2VMb2NhdGlvbigpXG4gICAgICAgIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICAgIHBhdGhuYW1lOiByb3V0ZXIuc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgIH0pLCBtYXRjaGVzKSA6IGdldEtleTtcbiAgICAgICAgbGV0IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiA9IHJvdXRlciQxID09IG51bGwgPyB2b2lkIDAgOiByb3V0ZXIkMS5lbmFibGVTY3JvbGxSZXN0b3JhdGlvbihzYXZlZFNjcm9sbFBvc2l0aW9ucywgKCkgPT4gd2luZG93LnNjcm9sbFksIGdldEtleVdpdGhvdXRCYXNlbmFtZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24gJiYgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uKCk7XG4gICAgICB9LCBbcm91dGVyJDEsIGJhc2VuYW1lLCBnZXRLZXldKTtcblxuICAgICAgLy8gUmVzdG9yZSBzY3JvbGxpbmcgd2hlbiBzdGF0ZS5yZXN0b3JlU2Nyb2xsUG9zaXRpb24gY2hhbmdlc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEV4cGxpY2l0IGZhbHNlIG1lYW5zIGRvbid0IGRvIGFueXRoaW5nICh1c2VkIGZvciBzdWJtaXNzaW9ucylcbiAgICAgICAgaWYgKHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcbiAgICAgICAgaWYgKHR5cGVvZiByZXN0b3JlU2Nyb2xsUG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdG8gc2Nyb2xsIHRvIHRoZSBoYXNoXG4gICAgICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGVjb2RlVVJJQ29tcG9uZW50KGxvY2F0aW9uLmhhc2guc2xpY2UoMSkpKTtcbiAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgcmVzZXQgaWYgdGhpcyBuYXZpZ2F0aW9uIG9wdGVkIG91dFxuICAgICAgICBpZiAocHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGdvIHRvIHRoZSB0b3Agb24gbmV3IGxvY2F0aW9uc1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICB9LCBbbG9jYXRpb24sIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0XSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBiZWZvcmV1bmxvYWRgIGV2ZW50LiBUaGlzIGlzXG4gICAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAgICogcmVmcmVzaGVzLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbiBjcmVhdGVkIHdpdGhcbiAgICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICAgKi9cbiAgZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgbGV0IHtcbiAgICAgIGNhcHR1cmVcbiAgICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHtcbiAgICAgICAgY2FwdHVyZVxuICAgICAgfSA6IHVuZGVmaW5lZDtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICAgIH07XG4gICAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYHBhZ2VoaWRlYCBldmVudC4gVGhpcyBpc1xuICAgKiB1c2VmdWwgZm9yIHNhdmluZyBzb21lIGRhdGEgdG8gYHdpbmRvdy5sb2NhbFN0b3JhZ2VgIGp1c3QgYmVmb3JlIHRoZSBwYWdlXG4gICAqIHJlZnJlc2hlcy4gIFRoaXMgZXZlbnQgaXMgYmV0dGVyIHN1cHBvcnRlZCB0aGFuIGJlZm9yZXVubG9hZCBhY3Jvc3MgYnJvd3NlcnMuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxuICAgKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gICAqL1xuICBmdW5jdGlvbiB1c2VQYWdlSGlkZShjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGxldCB7XG4gICAgICBjYXB0dXJlXG4gICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7XG4gICAgICAgIGNhcHR1cmVcbiAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgICAgfTtcbiAgICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIGFyb3VuZCB1c2VCbG9ja2VyIHRvIHNob3cgYSB3aW5kb3cuY29uZmlybSBwcm9tcHQgdG8gdXNlcnMgaW5zdGVhZFxuICAgKiBvZiBidWlsZGluZyBhIGN1c3RvbSBVSSB3aXRoIHVzZUJsb2NrZXIuXG4gICAqXG4gICAqIFdhcm5pbmc6IFRoaXMgaGFzICphIGxvdCBvZiByb3VnaCBlZGdlcyogYW5kIGJlaGF2ZXMgdmVyeSBkaWZmZXJlbnRseSAoYW5kXG4gICAqIHZlcnkgaW5jb3JyZWN0bHkgaW4gc29tZSBjYXNlcykgYWNyb3NzIGJyb3dzZXJzIGlmIHVzZXIgY2xpY2sgYWRkaXRpb25cbiAgICogYmFjay9mb3J3YXJkIG5hdmlnYXRpb25zIHdoaWxlIHRoZSBjb25maXJtIGlzIG9wZW4uICBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIGZ1bmN0aW9uIHVzZVByb21wdChfcmVmMTEpIHtcbiAgICBsZXQge1xuICAgICAgd2hlbixcbiAgICAgIG1lc3NhZ2VcbiAgICB9ID0gX3JlZjExO1xuICAgIGxldCBibG9ja2VyID0gcmVhY3RSb3V0ZXIudW5zdGFibGVfdXNlQmxvY2tlcih3aGVuKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgICAgbGV0IHByb2NlZWQgPSB3aW5kb3cuY29uZmlybShtZXNzYWdlKTtcbiAgICAgICAgaWYgKHByb2NlZWQpIHtcbiAgICAgICAgICAvLyBUaGlzIHRpbWVvdXQgaXMgbmVlZGVkIHRvIGF2b2lkIGEgd2VpcmQgXCJyYWNlXCIgb24gUE9QIG5hdmlnYXRpb25zXG4gICAgICAgICAgLy8gYmV0d2VlbiB0aGUgYHdpbmRvdy5oaXN0b3J5YCByZXZlcnQgbmF2aWdhdGlvbiBhbmQgdGhlIHJlc3VsdCBvZlxuICAgICAgICAgIC8vIGB3aW5kb3cuY29uZmlybWBcbiAgICAgICAgICBzZXRUaW1lb3V0KGJsb2NrZXIucHJvY2VlZCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2Jsb2NrZXIsIG1lc3NhZ2VdKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgIXdoZW4pIHtcbiAgICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgICAgfVxuICAgIH0sIFtibG9ja2VyLCB3aGVuXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSB2aWV3IHRyYW5zaXRpb24gdG8gdGhlXG4gICAqIGdpdmVuIGhyZWYuICBZb3UgY2FuIHVzZSB0aGlzIHZhbHVlIHRvIHJlbmRlciBDU1MgY2xhc3NlcyBvciB2aWV3VHJhbnNpdGlvbk5hbWVcbiAgICogc3R5bGVzIG9udG8geW91ciBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0gaHJlZiBUaGUgZGVzdGluYXRpb24gaHJlZlxuICAgKiBAcGFyYW0gW29wdHMucmVsYXRpdmVdIFJlbGF0aXZlIHJvdXRpbmcgdHlwZSAoXCJyb3V0ZVwiIHwgXCJwYXRoXCIpXG4gICAqL1xuICBmdW5jdGlvbiB1c2VWaWV3VHJhbnNpdGlvblN0YXRlKHRvLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cbiAgICBsZXQgdnRDb250ZXh0ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFZpZXdUcmFuc2l0aW9uQ29udGV4dCk7XG4gICAgISh2dENvbnRleHQgIT0gbnVsbCkgPyByb3V0ZXIuVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJgdW5zdGFibGVfdXNlVmlld1RyYW5zaXRpb25TdGF0ZWAgbXVzdCBiZSB1c2VkIHdpdGhpbiBgcmVhY3Qtcm91dGVyLWRvbWAncyBgUm91dGVyUHJvdmlkZXJgLiAgXCIgKyBcIkRpZCB5b3UgYWNjaWRlbnRhbGx5IGltcG9ydCBgUm91dGVyUHJvdmlkZXJgIGZyb20gYHJlYWN0LXJvdXRlcmA/XCIpICA6IHZvaWQgMDtcbiAgICBsZXQge1xuICAgICAgYmFzZW5hbWVcbiAgICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2sudXNlVmlld1RyYW5zaXRpb25TdGF0ZSk7XG4gICAgbGV0IHBhdGggPSByZWFjdFJvdXRlci51c2VSZXNvbHZlZFBhdGgodG8sIHtcbiAgICAgIHJlbGF0aXZlOiBvcHRzLnJlbGF0aXZlXG4gICAgfSk7XG4gICAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBjdXJyZW50UGF0aCA9IHJvdXRlci5zdHJpcEJhc2VuYW1lKHZ0Q29udGV4dC5jdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCB2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICAgIGxldCBuZXh0UGF0aCA9IHJvdXRlci5zdHJpcEJhc2VuYW1lKHZ0Q29udGV4dC5uZXh0TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCB2dENvbnRleHQubmV4dExvY2F0aW9uLnBhdGhuYW1lO1xuXG4gICAgLy8gVHJhbnNpdGlvbiBpcyBhY3RpdmUgaWYgd2UncmUgZ29pbmcgdG8gb3IgY29taW5nIGZyb20gdGhlIGluZGljYXRlZFxuICAgIC8vIGRlc3RpbmF0aW9uLiAgVGhpcyBlbnN1cmVzIHRoYXQgb3RoZXIgUFVTSCBuYXZpZ2F0aW9ucyB0aGF0IHJldmVyc2VcbiAgICAvLyBhbiBpbmRpY2F0ZWQgdHJhbnNpdGlvbiBhcHBseS4gIEkuZS4sIG9uIHRoZSBsaXN0IHZpZXcgeW91IGhhdmU6XG4gICAgLy9cbiAgICAvLyAgIDxOYXZMaW5rIHRvPVwiL2RldGFpbHMvMVwiIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uPlxuICAgIC8vXG4gICAgLy8gSWYgeW91IGNsaWNrIHRoZSBicmVhZGNydW1iIGJhY2sgdG8gdGhlIGxpc3QgdmlldzpcbiAgICAvL1xuICAgIC8vICAgPE5hdkxpbmsgdG89XCIvbGlzdFwiIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uPlxuICAgIC8vXG4gICAgLy8gV2Ugc2hvdWxkIGFwcGx5IHRoZSB0cmFuc2l0aW9uIGJlY2F1c2UgaXQncyBpbmRpY2F0ZWQgYXMgYWN0aXZlIGdvaW5nXG4gICAgLy8gZnJvbSAvbGlzdCAtPiAvZGV0YWlscy8xIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIGFjdGl2ZSBvbiB0aGUgcmV2ZXJzZVxuICAgIC8vIChldmVuIHRob3VnaCB0aGlzIGlzbid0IHN0cmljdGx5IGEgUE9QIHJldmVyc2UpXG4gICAgcmV0dXJuIHJvdXRlci5tYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgbmV4dFBhdGgpICE9IG51bGwgfHwgcm91dGVyLm1hdGNoUGF0aChwYXRoLnBhdGhuYW1lLCBjdXJyZW50UGF0aCkgIT0gbnVsbDtcbiAgfVxuXG4gIC8vI2VuZHJlZ2lvblxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQWJvcnRlZERlZmVycmVkRXJyb3InLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLkFib3J0ZWREZWZlcnJlZEVycm9yOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0F3YWl0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5Bd2FpdDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdNZW1vcnlSb3V0ZXInLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLk1lbW9yeVJvdXRlcjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOYXZpZ2F0ZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuTmF2aWdhdGU7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmF2aWdhdGlvblR5cGUnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLk5hdmlnYXRpb25UeXBlOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ091dGxldCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuT3V0bGV0OyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1JvdXRlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5Sb3V0ZTsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdSb3V0ZXInLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLlJvdXRlcjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdSb3V0ZXMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLlJvdXRlczsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLlVOU0FGRV9EYXRhUm91dGVyQ29udGV4dDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQ7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVU5TQUZFX0xvY2F0aW9uQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuVU5TQUZFX0xvY2F0aW9uQ29udGV4dDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLlVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdVTlNBRkVfUm91dGVDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5VTlNBRkVfUm91dGVDb250ZXh0OyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1VOU0FGRV91c2VSb3V0ZUlkJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5VTlNBRkVfdXNlUm91dGVJZDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVNZW1vcnlSb3V0ZXInLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLmNyZWF0ZU1lbW9yeVJvdXRlcjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVQYXRoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5jcmVhdGVQYXRoOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmVyJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5kZWZlcjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnZW5lcmF0ZVBhdGgnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLmdlbmVyYXRlUGF0aDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpc1JvdXRlRXJyb3JSZXNwb25zZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuaXNSb3V0ZUVycm9yUmVzcG9uc2U7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnanNvbicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIuanNvbjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdtYXRjaFBhdGgnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLm1hdGNoUGF0aDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdtYXRjaFJvdXRlcycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIubWF0Y2hSb3V0ZXM7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncGFyc2VQYXRoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci5wYXJzZVBhdGg7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVkaXJlY3QnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnJlZGlyZWN0OyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3JlZGlyZWN0RG9jdW1lbnQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnJlZGlyZWN0RG9jdW1lbnQ7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVuZGVyTWF0Y2hlcycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIucmVuZGVyTWF0Y2hlczsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyZXNvbHZlUGF0aCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIucmVzb2x2ZVBhdGg7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndW5zdGFibGVfdXNlQmxvY2tlcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudW5zdGFibGVfdXNlQmxvY2tlcjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VBY3Rpb25EYXRhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VBY3Rpb25EYXRhOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZUFzeW5jRXJyb3InLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnVzZUFzeW5jRXJyb3I7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlQXN5bmNWYWx1ZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlQXN5bmNWYWx1ZTsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VIcmVmJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VIcmVmOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZUluUm91dGVyQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlSW5Sb3V0ZXJDb250ZXh0OyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZUxvYWRlckRhdGEnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnVzZUxvYWRlckRhdGE7IH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndXNlTG9jYXRpb24nLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnVzZUxvY2F0aW9uOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZU1hdGNoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VNYXRjaDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VNYXRjaGVzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VNYXRjaGVzOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZU5hdmlnYXRlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VOYXZpZ2F0ZTsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VOYXZpZ2F0aW9uJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VOYXZpZ2F0aW9uOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZU5hdmlnYXRpb25UeXBlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VOYXZpZ2F0aW9uVHlwZTsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VPdXRsZXQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0Um91dGVyLnVzZU91dGxldDsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VPdXRsZXRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VPdXRsZXRDb250ZXh0OyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZVBhcmFtcycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlUGFyYW1zOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZVJlc29sdmVkUGF0aCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlUmVzb2x2ZWRQYXRoOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZVJldmFsaWRhdG9yJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VSZXZhbGlkYXRvcjsgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VSb3V0ZUVycm9yJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdFJvdXRlci51c2VSb3V0ZUVycm9yOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZVJvdXRlTG9hZGVyRGF0YScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlUm91dGVMb2FkZXJEYXRhOyB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZVJvdXRlcycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3RSb3V0ZXIudXNlUm91dGVzOyB9XG4gIH0pO1xuICBleHBvcnRzLkJyb3dzZXJSb3V0ZXIgPSBCcm93c2VyUm91dGVyO1xuICBleHBvcnRzLkZvcm0gPSBGb3JtO1xuICBleHBvcnRzLkhhc2hSb3V0ZXIgPSBIYXNoUm91dGVyO1xuICBleHBvcnRzLkxpbmsgPSBMaW5rO1xuICBleHBvcnRzLk5hdkxpbmsgPSBOYXZMaW5rO1xuICBleHBvcnRzLlJvdXRlclByb3ZpZGVyID0gUm91dGVyUHJvdmlkZXI7XG4gIGV4cG9ydHMuU2Nyb2xsUmVzdG9yYXRpb24gPSBTY3JvbGxSZXN0b3JhdGlvbjtcbiAgZXhwb3J0cy5VTlNBRkVfVmlld1RyYW5zaXRpb25Db250ZXh0ID0gVmlld1RyYW5zaXRpb25Db250ZXh0O1xuICBleHBvcnRzLlVOU0FGRV91c2VTY3JvbGxSZXN0b3JhdGlvbiA9IHVzZVNjcm9sbFJlc3RvcmF0aW9uO1xuICBleHBvcnRzLmNyZWF0ZUJyb3dzZXJSb3V0ZXIgPSBjcmVhdGVCcm93c2VyUm91dGVyO1xuICBleHBvcnRzLmNyZWF0ZUhhc2hSb3V0ZXIgPSBjcmVhdGVIYXNoUm91dGVyO1xuICBleHBvcnRzLmNyZWF0ZVNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcztcbiAgZXhwb3J0cy51bnN0YWJsZV9IaXN0b3J5Um91dGVyID0gSGlzdG9yeVJvdXRlcjtcbiAgZXhwb3J0cy51bnN0YWJsZV91c2VQcm9tcHQgPSB1c2VQcm9tcHQ7XG4gIGV4cG9ydHMudW5zdGFibGVfdXNlVmlld1RyYW5zaXRpb25TdGF0ZSA9IHVzZVZpZXdUcmFuc2l0aW9uU3RhdGU7XG4gIGV4cG9ydHMudXNlQmVmb3JlVW5sb2FkID0gdXNlQmVmb3JlVW5sb2FkO1xuICBleHBvcnRzLnVzZUZldGNoZXIgPSB1c2VGZXRjaGVyO1xuICBleHBvcnRzLnVzZUZldGNoZXJzID0gdXNlRmV0Y2hlcnM7XG4gIGV4cG9ydHMudXNlRm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb247XG4gIGV4cG9ydHMudXNlTGlua0NsaWNrSGFuZGxlciA9IHVzZUxpbmtDbGlja0hhbmRsZXI7XG4gIGV4cG9ydHMudXNlU2VhcmNoUGFyYW1zID0gdXNlU2VhcmNoUGFyYW1zO1xuICBleHBvcnRzLnVzZVN1Ym1pdCA9IHVzZVN1Ym1pdDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1yb3V0ZXItZG9tLmRldmVsb3BtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/react-router-dom/dist/umd/react-router-dom.development.js\n");

/***/ })

};
;